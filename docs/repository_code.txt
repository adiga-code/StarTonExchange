

================================================================================
FILE: parse.py
================================================================================

import os
import pathlib

def export_repo_to_text(root_dir, output_file, include_extensions=None, exclude_dirs=None):
    """Экспортирует код репозитория в текстовый файл"""
    if include_extensions is None:
        include_extensions = ['.py', '.js', '.html', '.css', '.md', '.java', '.c', '.cpp', '.h']
    
    if exclude_dirs is None:
        exclude_dirs = ['.git', '__pycache__', 'node_modules', 'venv', '.venv', 'env', 'dist', 'build']
    
    # Создаем папки для выходного файла если нужно
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    
    root_dir = pathlib.Path(root_dir).resolve()
    exclude_dirs_set = set(exclude_dirs)

    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(root_dir):
            root_path = pathlib.Path(root)
            
            # Фильтрация директорий (по имени)
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set]
            
            for file in files:
                file_path = root_path / file
                
                # Проверка расширения
                if file_path.suffix not in include_extensions:
                    continue

                # Пропуск если путь содержит исключённую папку (например: .../.venv/...)
                if any(part in exclude_dirs_set for part in file_path.parts):
                    continue
                
                try:
                    # Заголовок файла
                    rel_path = file_path.relative_to(root_dir)
                    outfile.write(f"\n\n{'=' * 80}\n")
                    outfile.write(f"FILE: {rel_path}\n")
                    outfile.write(f"{'=' * 80}\n\n")
                    
                    # Чтение содержимого
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                        
                except UnicodeDecodeError:
                    outfile.write(f"\n\n[BINARY FILE: {rel_path} - SKIPPED]\n")
                except Exception as e:
                    outfile.write(f"\n\n[ERROR READING {rel_path}: {str(e)}]\n")

if __name__ == "__main__":
    REPO_DIR = pathlib.Path(__file__).parent.resolve()
    OUTPUT_PATH = REPO_DIR / "docs/repository_code.txt"
    
    print(f"Старт экспорта репозитория: {REPO_DIR}")
    print(f"Выходной файл: {OUTPUT_PATH}")
    
    export_repo_to_text(
        root_dir=REPO_DIR,
        output_file=str(OUTPUT_PATH),
        include_extensions=[".py", ".js", ".html", ".css", ".md", ".ts", ".json",".tsx",".",".",".",],
        exclude_dirs=[".git", "__pycache__", "venv", ".venv", "env", "dist", "build", "node_modules"]
    )
    
    print(f"Экспорт завершен! Размер файла: {os.path.getsize(OUTPUT_PATH)/1024:.2f} KB")


================================================================================
FILE: README.md
================================================================================

Get started by customizing your environment (defined in the .idx/dev.nix file) with the tools and IDE extensions you'll need for your project!

Learn more at https://developers.google.com/idx/guides/customize-idx-env

================================================================================
FILE: replit.md
================================================================================

# Overview

This is a Telegram Mini App for a cryptocurrency exchange platform that allows users to buy and exchange Telegram Stars and TON coins. The application features a modern React frontend with a Node.js/Express backend, using PostgreSQL for data persistence and Drizzle ORM for database operations. The app integrates with Telegram's WebApp API to provide a seamless in-app experience for users to manage their crypto balances, complete tasks, and participate in a referral system.

# User Preferences

Preferred communication style: Simple, everyday language.

# System Architecture

## Frontend Architecture
The client-side application is built with React 18 and TypeScript, utilizing modern UI patterns and state management:

- **Framework**: React with TypeScript for type safety and developer experience
- **Routing**: Wouter for lightweight client-side routing
- **State Management**: TanStack Query (React Query) for server state management and caching
- **UI Components**: Radix UI primitives with custom Tailwind CSS styling following the shadcn/ui design system
- **Animations**: Framer Motion for smooth transitions and micro-interactions
- **Build Tool**: Vite for fast development and optimized production builds
- **Styling**: Tailwind CSS with CSS custom properties for theming support

The application follows a component-based architecture with reusable UI components and custom hooks for business logic. The main application structure includes a tabbed interface for buying crypto, completing tasks, and managing user profiles.

## Backend Architecture
The server-side implementation uses Node.js with Express for API endpoints and business logic:

- **Runtime**: Node.js with ES modules for modern JavaScript features
- **Framework**: Express.js for HTTP server and API routing
- **Database ORM**: Drizzle ORM for type-safe database operations
- **Session Management**: Connect-pg-simple for PostgreSQL-backed session storage
- **Development**: TSX for TypeScript execution and hot reloading

The backend follows a RESTful API design with separate modules for different concerns (routes, storage, database schema). It includes middleware for request logging and error handling, with a clean separation between API routes and business logic.

## Data Storage Solutions
The application uses PostgreSQL as the primary database with Drizzle ORM for schema definition and queries:

- **Database**: PostgreSQL with Neon serverless hosting
- **ORM**: Drizzle ORM with Zod schema validation
- **Schema Design**: Normalized tables for users, transactions, tasks, user tasks, and settings
- **Migration System**: Drizzle Kit for database schema migrations
- **Connection**: Neon serverless driver for PostgreSQL connections

The database schema supports user management, transaction history, task completion tracking, referral systems, and application settings. It includes proper foreign key relationships and indexing for performance.

## Authentication and Authorization
User authentication is simplified for the Telegram ecosystem:

- **Telegram Integration**: Uses Telegram WebApp user data for authentication
- **Session Management**: Telegram user ID as the primary identifier
- **Development Mode**: Mock user data for testing outside Telegram environment
- **Authorization**: Simple middleware to extract current user from Telegram headers

The system assumes users are authenticated through Telegram's WebApp interface, eliminating the need for traditional login/logout flows.

# External Dependencies

## Telegram Integration
- **Telegram WebApp API**: Core integration for user authentication, haptic feedback, UI theming, and in-app sharing
- **Bot Integration**: Designed to work with a Telegram bot for user onboarding and notifications

## Database Services
- **Neon Database**: Serverless PostgreSQL hosting for production data storage
- **Drizzle ORM**: Type-safe database operations and schema management
- **Connect-pg-simple**: PostgreSQL session store for Express sessions

## UI and Styling
- **Radix UI**: Accessible component primitives for complex UI elements
- **Tailwind CSS**: Utility-first CSS framework for responsive design
- **Framer Motion**: Animation library for smooth transitions and interactions
- **Lucide React**: Icon library for consistent iconography

## Development Tools
- **Vite**: Build tool with hot module replacement and optimized bundling
- **TypeScript**: Static type checking for both frontend and backend code
- **ESBuild**: Fast JavaScript bundler for production builds
- **Replit Integration**: Development environment with runtime error overlays and cartographer plugin

## Payment Processing
The application is structured to handle cryptocurrency transactions but specific payment processor integrations are not implemented in the current codebase. The system includes transaction tracking and balance management for future payment integration.

================================================================================
FILE: .idx\airules.md
================================================================================

# Gemini AI Rules for Firebase Studio Nix Projects

## 1. Persona & Expertise

You are an expert in configuring development environments within Firebase Studio. You are proficient in using the `dev.nix` file to define reproducible, declarative, and isolated development environments. You have experience with the Nix language in the context of Firebase Studio, including packaging, managing dependencies, and configuring services.

## 2. Project Context

This project is a Nix-based environment for Firebase Studio, defined by a `.idx/dev.nix` file. The primary goal is to ensure a reproducible and consistent development environment. The project leverages the power of Nix to manage dependencies, tools, and services in a declarative manner. **Note:** This is not a Nix Flake-based environment.

## 3. `dev.nix` Configuration

The `.idx/dev.nix` file is the single source of truth for the development environment. Here are some of the most common configuration options:

### `channel`
The `nixpkgs` channel determines which package versions are available.

```nix
{ pkgs, ... }: {
  channel = "stable-24.05"; # or "unstable"
}
```

### `packages`
A list of packages to install from the specified channel. You can search for packages on the [NixOS package search](https://search.nixos.org/packages).

```nix
{ pkgs, ... }: {
  packages = [
    pkgs.nodejs_20
    pkgs.go
  ];
}
```

### `env`
A set of environment variables to define within the workspace.

```nix
{ pkgs, ... }: {
  env = {
    API_KEY = "your-secret-key";
  };
}
```

### `idx.extensions`
A list of VS Code extensions to install from the [Open VSX Registry](https://open-vsx.org/).

```nix
{ pkgs, ... }: {
  idx = {
    extensions = [
      "vscodevim.vim"
      "golang.go"
    ];
  };
}
```

### `idx.workspace`
Workspace lifecycle hooks.

- **`onCreate`:** Runs when a workspace is first created.
- **`onStart`:** Runs every time the workspace is (re)started.

```nix
{ pkgs, ... }: {
  idx = {
    workspace = {
      onCreate = {
        npm-install = "npm install";
      };
      onStart = {
        start-server = "npm run dev";
      };
    };
  };
}
```

### `idx.previews`
Configure a web preview for your application. The `$PORT` variable is dynamically assigned.

```nix
{ pkgs, ... }: {
  idx = {
    previews = {
      enable = true;
      previews = {
        web = {
          command = ["npm" "run" "dev" "--" "--port" "$PORT"];
          manager = "web";
        };
      };
    };
  };
}
```

## 4. Example Setups for Common Frameworks

Here are some examples of how to configure your `dev.nix` for common languages and frameworks.

### Node.js Web Server
This example sets up a Node.js environment, installs dependencies, and runs a development server with a web preview.

```nix
{ pkgs, ... }: {
  packages = [ pkgs.nodejs_20 ];
  idx = {
    extensions = [ "dbaeumer.vscode-eslint" ];
    workspace = {
      onCreate = {
        npm-install = "npm install";
      };
      onStart = {
        dev-server = "npm run dev";
      };
    };
    previews = {
      enable = true;
      previews = {
        web = {
          command = ["npm" "run" "dev" "--" "--port" "$PORT"];
          manager = "web";
        };
      };
    };
  };
}
```

### Python with Flask
This example sets up a Python environment for a Flask web server. Remember to create a `requirements.txt` file with `Flask` in it.

```nix
{ pkgs, ... }: {
  packages = [ pkgs.python3 pkgs.pip ];
  idx = {
    extensions = [ "ms-python.python" ];
    workspace = {
      onCreate = {
        pip-install = "pip install -r requirements.txt";
      };
    };
    previews = {
      enable = true;
      previews = {
        web = {
          command = ["flask" "run" "--port" "$PORT"];
          manager = "web";
        };
      };
    };
  };
}
```

### Go CLI
This example sets up a Go environment for building a command-line interface.

```nix
{ pkgs, ... }: {
  packages = [ pkgs.go ];
  idx = {
    extensions = [ "golang.go" ];
    workspace = {
      onCreate = {
        go-mod = "go mod tidy";
      };
      onStart = {
        run-app = "go run .";
      };
    };
  };
}
```

## 5. Interaction Guidelines

- Assume the user is familiar with general software development concepts but may be new to Nix and Firebase Studio.
- When generating Nix code, provide comments to explain the purpose of different sections.
- Explain the benefits of using `dev.nix` for reproducibility and dependency management.
- If a request is ambiguous, ask for clarification on the desired tools, libraries, and versions to be included in the environment.
- When suggesting changes to `dev.nix`, explain the impact of the changes on the development environment and remind the user to reload the environment.


================================================================================
FILE: backend\bot.py
================================================================================

import asyncio
import logging
import os
from aiogram import Bot, Dispatcher, Router, F
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton, WebAppInfo
from aiogram.filters import CommandStart
from aiogram.fsm.storage.memory import MemoryStorage
from dotenv import load_dotenv

from database import AsyncSessionLocal, init_db, init_default_data
from storage import Storage
from schemas import UserCreate

# Load environment variables
load_dotenv()

# Bot configuration
BOT_TOKEN = os.getenv('BOT_TOKEN')
WEBAPP_URL = os.getenv('WEBAPP_URL', 'https://app1.hezh-digital.ru')

if not BOT_TOKEN:
    raise ValueError("BOT_TOKEN not found in environment variables")

# Initialize bot and dispatcher
bot = Bot(token=BOT_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)
router = Router()
dp.include_router(router)

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

async def get_or_create_user(telegram_user, referrer_user_id=None) -> bool:
    """Get or create user in database with referral support"""
    async with AsyncSessionLocal() as session:
        storage_instance = Storage(session)
        
        # Проверяем, существует ли пользователь
        existing_user = await storage_instance.get_user_by_telegram_id(str(telegram_user.id))
        
        if not existing_user:
            # Создаем нового пользователя
            user_data = UserCreate(
                telegram_id=str(telegram_user.id),
                username=telegram_user.username,
                first_name=telegram_user.first_name,
                last_name=telegram_user.last_name,
                referred_by=referrer_user_id  # ВАЖНО: устанавливаем реферера
            )
            
            try:
                new_user = await storage_instance.create_user(user_data)
                logger.info(f"Created new user: {new_user.id} (Telegram ID: {telegram_user.id})")
                
                # Если есть реферер, начисляем ему бонус за приглашение
                if referrer_user_id:
                    await storage_instance.process_referral_registration(referrer_user_id, new_user.id)
                    logger.info(f"Processed referral registration bonus for referrer: {referrer_user_id}")
                
                return True
            except Exception as e:
                logger.error(f"Error creating user: {e}")
                return False
        else:
            logger.info(f"User already exists: {existing_user.id} (Telegram ID: {telegram_user.id})")
            return True

@router.message(CommandStart())
async def start_command(message: Message):
    """Handle /start command with referral support"""
    user = message.from_user
    
    # Извлекаем аргументы команды /start (реферальный код)
    command_args = message.text.split()[1:] if message.text and len(message.text.split()) > 1 else []
    referrer_user_id = None
    
    if command_args:
        referral_param = command_args[0]
        logger.info(f"Start command with parameter: {referral_param}")
        
        # Получаем префикс из настроек для проверки
        async with AsyncSessionLocal() as session:
            storage_instance = Storage(session)
            prefix = await storage_instance.get_cached_setting("referral_prefix")
            
            # Проверяем, что параметр начинается с нашего префикса
            if referral_param.startswith(prefix):
                referral_code = referral_param[len(prefix):]
                logger.info(f"Extracted referral code: {referral_code}")
                
                # Ищем пользователя-реферера по коду
                referrer_user = await storage_instance.get_user_by_referral_code(referral_code)
                if referrer_user:
                    referrer_user_id = referrer_user.id
                    logger.info(f"Found referrer: {referrer_user.telegram_id} for new user: {user.id}")
                else:
                    logger.warning(f"Referrer not found for code: {referral_code}")
    
    # Создаем или получаем пользователя с реферером
    user_created = await get_or_create_user(user, referrer_user_id)
    
    if not user_created:
        await message.answer("❌ Произошла ошибка при регистрации.")
        return
    
    # Формируем приветственное сообщение
    welcome_text = "🎉 <b>Добро пожаловать в Stars Exchange!</b>\n\n"
    welcome_text += "💫 Обменивайте Telegram Stars на TON и обратно с лучшими курсами!\n\n"
    
    if referrer_user_id:
        welcome_text += "🎁 <b>Вы пришли по реферальной ссылке!</b>\n"
        welcome_text += "Ваш друг получит бонус за приглашение, а вы - за активность!\n\n"
    
    welcome_text += "🚀 Нажмите кнопку ниже, чтобы начать:"
    
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="🚀 Открыть Stars Exchange",
                    web_app=WebAppInfo(url=WEBAPP_URL)
                )
            ],
            [
                InlineKeyboardButton(
                    text="👥 Рефералы",
                    callback_data="referrals"
                ),
                InlineKeyboardButton(
                    text="💰 Баланс", 
                    callback_data="balance"
                )
            ]
        ]
    )
    
    await message.answer(welcome_text, reply_markup=keyboard, parse_mode="HTML")
        
@router.message(F.text == "💰 Баланс")
async def balance_command(message: Message):
    """Handle balance inquiry"""
    user = message.from_user
    
    async with AsyncSessionLocal() as session:
        storage_instance = Storage(session)
        db_user = await storage_instance.get_user_by_telegram_id(str(user.id))
        
        if not db_user:
            await message.answer("❌ Пользователь не найден. Отправьте /start для регистрации.")
            return
        
        balance_text = f"""
💰 <b>Ваш баланс:</b>

⭐ Telegram Stars: <b>{db_user.stars_balance}</b>
💎 TON Balance: <b>{db_user.ton_balance}</b>

📊 <b>Статистика:</b>
🎯 Заданий выполнено: <b>{db_user.tasks_completed}</b>
👥 Рефералов: <b>{db_user.total_referral_earnings}</b>
🏆 Всего заработано: <b>{db_user.total_stars_earned} звезд</b>
        """
        
        keyboard = InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    InlineKeyboardButton(
                        text="🚀 Открыть приложение",
                        web_app=WebAppInfo(url=WEBAPP_URL)
                    )
                ]
            ]
        )
        
        await message.answer(balance_text, reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text == "📈 Задания")
async def tasks_command(message: Message):
    """Handle tasks inquiry"""
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="🎯 Выполнить задания",
                    web_app=WebAppInfo(url=f"{WEBAPP_URL}#tasks")
                )
            ]
        ]
    )
    
    tasks_text = """
🎯 <b>Доступные задания:</b>

⭐ <b>Ежедневные:</b>
• Ежедневный вход: +10 звезд

🎁 <b>Социальные:</b>
• Пригласить друга: +25 звезд
• Подписаться на канал: +50 звезд

💡 <b>Выполняйте задания каждый день и зарабатывайте больше звезд!</b>
    """
    
    await message.answer(tasks_text, reply_markup=keyboard, parse_mode="HTML")

@router.message(F.text == "👥 Рефералы")
async def referrals_command(message: Message):
    """Handle referrals inquiry"""
    user = message.from_user
    
    async with AsyncSessionLocal() as session:
        storage_instance = Storage(session)
        db_user = await storage_instance.get_user_by_telegram_id(str(user.id))
        
        if not db_user:
            await message.answer("❌ Пользователь не найден. Отправьте /start для регистрации.")
            return
        
        storage_instance = Storage(session)
        bot_url = await storage_instance.get_cached_setting("bot_base_url")
        prefix = await storage_instance.get_cached_setting("referral_prefix")
        referral_link = f"{bot_url}?start={prefix}{db_user.referral_code}"
        
        bonus_percent = await storage_instance.get_cached_setting("referral_bonus_percentage")
        referrals_text = f"""
👥 <b>Реферальная программа</b>

💰 <b>Зарабатывайте {bonus_percent}% с каждой покупки друзей!</b>

🔗 <b>Ваша реферальная ссылка:</b>
<code>{referral_link}</code>

📊 <b>Статистика:</b>
👥 Приглашено друзей: <b>0</b>
💰 Заработано с рефералов: <b>{db_user.total_referral_earnings} звезд</b>

💡 <b>Поделитесь ссылкой с друзьями и зарабатывайте вместе!</b>
        """
        
        keyboard = InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    InlineKeyboardButton(
                        text="📤 Поделиться ссылкой",
                        switch_inline_query=f"Попробуй этот крутой обменник Stars и TON! {referral_link}"
                    )
                ]
            ]
        )
        
        await message.answer(referrals_text, reply_markup=keyboard, parse_mode="HTML")

@router.message()
async def default_handler(message: Message):
    """Handle all other messages"""
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(
                    text="🚀 Открыть Stars Exchange",
                    web_app=WebAppInfo(url=WEBAPP_URL)
                )
            ]
        ]
    )
    
    await message.answer(
        "👋 Используйте кнопку ниже для доступа к Stars Exchange:",
        reply_markup=keyboard
    )

async def main():
    """Main function to run the bot"""
    try:
        # Start polling
        logger.info("Starting bot...")
        await dp.start_polling(bot)
        
    except Exception as e:
        logger.error(f"Error running bot: {e}")
    finally:
        await bot.session.close()

if __name__ == "__main__":
    asyncio.run(main())

================================================================================
FILE: backend\database.py
================================================================================

from sqlalchemy import create_engine
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from models import Base
import os

# Database URL for SQLite
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./app.db")

# Create async engine
engine = create_async_engine(
    DATABASE_URL,
    echo=True,  # Set to False in production
    future=True
)

# Create async session factory
AsyncSessionLocal = sessionmaker(
    engine, class_=AsyncSession, expire_on_commit=False
)

async def init_db():
    """Initialize database tables"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def get_db():
    """Dependency to get DB session"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()

async def init_default_data():
    """Initialize default settings and tasks"""
    async with AsyncSessionLocal() as session:
        from models import Setting, Task
        from sqlalchemy import select
        
        # Check if settings already exist
        result = await session.execute(select(Setting))
        if result.first():
            return  # Data already initialized
        
        # Initialize default settings
        default_settings = [
            Setting(key="stars_price", value="2.30"),
            Setting(key="markup_percentage", value="5"),
            Setting(key="bot_base_url", value="https://t.me/starsexchange_bot"),
            Setting(key="referral_prefix", value="ref"),
            Setting(key="referral_bonus_percentage", value="10"),
            Setting(key="referral_registration_bonus", value="25"),
            Setting(key="copy_success", value="Ссылка скопирована!"),
            Setting(key="copy_error", value="Не удалось скопировать ссылку"),
            Setting(key="loading", value="Загрузка..."),
            Setting(key="error", value="Ошибка"),
            Setting(key="ton_markup_percentage", value="5"),
            Setting(key="ton_price_cache_minutes", value="15"),
            Setting(key="ton_fallback_price", value="420"),
        ]
        
        for setting in default_settings:
            session.add(setting)
        
        # Initialize default tasks only if empty
        existing_tasks = await session.execute(select(Task))
        if not existing_tasks.first():
            default_tasks = [
                Task(
                    title="Ежедневный вход",
                    description="Заходите каждый день",
                    reward=10,
                    type="daily",
                    action="daily_login",
                    is_active=True,
                    completion_title="Ежедневный вход засчитан!",
                    completion_text="Вы получили 10 звезд",
                    button_text="Войти"
                ),
                Task(
                    title="Поделиться с другом",
                    description="Пригласите 1 друга",
                    reward=25,
                    type="referral",
                    action="share_app",
                    is_active=True,
                    completion_title="Друг приглашен!",
                    completion_text="Вы получили 25 звезд за приглашение",
                    share_text="Попробуй этот крутой обменник Stars и TON!",
                    button_text="Пригласить"
                ),
                Task(
                    title="Подписаться на канал",
                    description="@starsexchange_news",
                    reward=50,
                    type="social",
                    action="follow_channel",
                    is_active=True,
                    completion_title="Подписка оформлена!",
                    completion_text="Вы получили 50 звезд за подписку",
                    button_text="Подписаться"
                ),
            ]
            
            for task in default_tasks:
                session.add(task)
        
        await session.commit()
        print("Default data initialized")


================================================================================
FILE: backend\main.py
================================================================================

from fastapi import FastAPI, Depends, HTTPException, Header, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional, List
import asyncio
import os
import httpx
import logging
from datetime import datetime, date
from decimal import Decimal
from dotenv import load_dotenv
import base64
from pyrogram import Client
from pyrogram.errors import UsernameNotOccupied, UsernameInvalid, FloodWait, AuthKeyUnregistered
from ton_price_service import ton_price_service

# Load environment variables
load_dotenv()

from database import get_db, init_db, init_default_data, AsyncSessionLocal
from api import AsyncFragmentAPIClient
from storage import Storage
from telegram_auth import get_current_user
from robokassa import get_robokassa
from schemas import *
from models import User, Transaction
import json
import webhooks


# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="Stars Exchange API", version="1.0.0")
app.include_router(webhooks.router)
# CORS middleware for development
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://localhost:5173"],  # Vite dev server
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# Request logging middleware
@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = datetime.now()
    
    response = await call_next(request)
    
    duration = (datetime.now() - start_time).total_seconds() * 1000
    
    if request.url.path.startswith("/api"):
        logger.info(f"{request.method} {request.url.path} {response.status_code} in {duration:.0f}ms")
    
    return response

# Dependency to get storage
async def get_storage(db: AsyncSession = Depends(get_db)):
    try:
        yield Storage(db)
        await db.commit()
    except:
        await db.rollback()
        raise
    finally:
        await db.close()

# Dependency to get current user
async def get_authenticated_user(
    storage: Storage = Depends(get_storage),
    x_telegram_init_data: Optional[str] = Header(None)
) -> User:
    user = await get_current_user(storage, None, x_telegram_init_data)
    if not user:
        raise HTTPException(status_code=403, detail="Invalid or missing Telegram authentication data")
    return user

telegram_client = None
connected_client = None

async def ensure_telegram_connection():
    global connected_client
    logger.info(f"Current connected_client state: {connected_client}")
    
    if connected_client is None:
        logger.info("Creating new telegram connection...")
        session_string = os.getenv('TELEGRAM_SESSION_STRING')
        if session_string:
            connected_client = Client("my_account", session_string=session_string)
            await connected_client.start()
            logger.info("Global telegram session started")
        else:
            logger.error("No session string found")
            return None
    else:
        logger.info("Using existing telegram connection")
    
    return connected_client

# User routes
@app.post("/api/users", response_model=UserResponse)
async def create_user(
    user_data: UserCreate,
    storage: Storage = Depends(get_storage)
):
    try:
        existing_user = await storage.get_user_by_telegram_id(user_data.telegram_id)
        if existing_user:
            return existing_user
        
        user = await storage.create_user(user_data)
        logger.info(f"Created user: {user.id} telegramId: {user.telegram_id}")
        return user
    except Exception as e:
        logger.error(f"Error creating user: {e}")
        raise HTTPException(status_code=400, detail="Invalid user data")

@app.get("/api/users/me", response_model=UserResponse)
async def get_current_user_info(
    current_user: User = Depends(get_authenticated_user)
):
    return current_user

@app.put("/api/users/me", response_model=UserResponse)
async def update_current_user(
    user_data: UserUpdate,
    current_user: User = Depends(get_authenticated_user),
    storage: Storage = Depends(get_storage)
):
    """Обновить данные текущего пользователя"""
    try:
        # Создаем словарь только с переданными данными (не None)
        update_data = {}
        if user_data.username is not None:
            update_data["username"] = user_data.username
        if user_data.first_name is not None:
            update_data["first_name"] = user_data.first_name
        if user_data.last_name is not None:
            update_data["last_name"] = user_data.last_name  
        if user_data.notifications_enabled is not None:
            update_data["notifications_enabled"] = user_data.notifications_enabled
            
        if not update_data:
            # Если нет данных для обновления, просто возвращаем текущего пользователя
            return current_user
            
        # Обновляем пользователя
        updated_user = await storage.update_user(current_user.id, update_data)
        
        if not updated_user:
            raise HTTPException(status_code=404, detail="User not found")
            
        logger.info(f"User {current_user.telegram_id} updated: {update_data}")
        return updated_user
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating user: {e}")
        raise HTTPException(status_code=500, detail="Failed to update user")

@app.get("/api/transactions/history", response_model=TransactionHistoryResponse)
async def get_user_transactions_history(
    current_user: User = Depends(get_authenticated_user),
    storage: Storage = Depends(get_storage)
):
    """Получить историю транзакций пользователя"""
    try:
        transactions = await storage.get_transactions_by_user_id(current_user.id)
        
        # Фильтруем только покупки (тип "purchase")
        purchase_transactions = [t for t in transactions if t.type == "purchase"]
        
        # Преобразуем в нужный формат для фронтенда
        transaction_history = []
        for transaction in purchase_transactions:
            # Определяем тип транзакции и иконку
            transaction_type = "purchase"
            icon_type = "star" if transaction.currency == "stars" else "ton"
            
            # Форматируем описание
            if transaction.type == "purchase":
                if transaction.currency == "stars":
                    description = f"Покупка {int(transaction.amount)} звезд"
                elif transaction.currency == "ton":
                    description = f"Покупка {float(transaction.amount)} TON"
                else:
                    description = transaction.description or f"Покупка {transaction.currency}"
            elif transaction.type == "task_reward":
                description = transaction.description or f"Награда за задание"
                icon_type = "star"
            else:
                description = transaction.description or f"Транзакция {transaction.type}"
            
            # Определяем статус на русском
            status_map = {
                "completed": "Успешно",
                "pending": "В обработке",
                "failed": "Ошибка",
                "cancelled": "Отменено"
            }
            status_text = status_map.get(transaction.status, transaction.status)
            
            # Определяем цвет статуса
            status_color = {
                "completed": "green",
                "pending": "yellow", 
                "failed": "red",
                "cancelled": "gray"
            }.get(transaction.status, "gray")
            
            # Форматирование даты с русскими месяцами
            month_names = {
                1: "янв", 2: "фев", 3: "мар", 4: "апр", 5: "май", 6: "июн",
                7: "июл", 8: "авг", 9: "сен", 10: "окт", 11: "ноя", 12: "дек"
            }
            created_date = transaction.created_at
            formatted_date = f"{created_date.day} {month_names[created_date.month]} {created_date.year}, {created_date.strftime('%H:%M')}"
            
            transaction_history.append({
                "id": transaction.id,
                "description": description,
                "amount": float(transaction.amount),
                "currency": transaction.currency,
                "rub_amount": float(transaction.rub_amount) if transaction.rub_amount else None,
                "status": transaction.status,
                "status_text": status_text,
                "status_color": status_color,
                "icon_type": icon_type,
                "created_at": transaction.created_at.isoformat(),
                "created_at_formatted": formatted_date
            })
        
        # Сортируем по дате создания (новые сверху)
        transaction_history.sort(key=lambda x: x["created_at"], reverse=True)
        
        return {
            "success": True, 
            "transactions": transaction_history,
            "count": len(transaction_history)
        }
        
    except Exception as e:
        logger.error(f"Error getting transactions history: {e}")
        raise HTTPException(status_code=500, detail="Failed to get transactions history")

@app.get("/api/getPhoto")
async def get_photo(username: str):
    logger.info(f"Getting photo for username: {username}")
    
    try:
        logger.info(f"Getting photo for username: {username}")
        # Добавляем проверку на существование fragment_api_client
        if not hasattr(app.state, 'fragment_api_client') or app.state.fragment_api_client is None:
            logger.warning("Fragment API client not initialized")
            # Возвращаем аватар по умолчанию
            avatar_url = f"https://ui-avatars.com/api/?name={username}&size=128&background=4E7FFF&color=fff"
            return {
                "photo_url": avatar_url,
                "first_name": username,
                "success": True
            }
        
        # Вызываем get_user_info с обработкой ошибок
        user_info = await app.state.fragment_api_client.get_user_info(username)
        
        # Проверяем результат
        if not user_info or not isinstance(user_info, dict):
            logger.warning(f"Invalid response from Fragment API for user {username}")
            raise Exception("Invalid API response")
            
        if not user_info.get('success') or not user_info.get('found'):
            logger.warning(f"User {username} not found in Fragment API")
            # Возвращаем аватар по умолчанию
            avatar_url = f"https://ui-avatars.com/api/?name={username}&size=128&background=4E7FFF&color=fff"
            return {
                "photo_url": avatar_url,
                "first_name": username,
                "success": True
            }
        
        # Получаем данные пользователя из ответа API
        user_name = user_info.get('name') or user_info.get('username') or username
        photo_html = user_info.get('photo', '')
        
        logger.info(f"Found user: {user_name}, has_photo: {bool(photo_html)}")
        
        # Пытаемся извлечь URL фото из HTML
        if photo_html and photo_html.strip():
            try:
                import re
                src_match = re.search(r'src="([^"]*)"', photo_html)
                if src_match:
                    photo_url = src_match.group(1)
                    return {
                        "photo_url": photo_url,
                        "first_name": user_name,
                        "success": True
                    }
                else:
                    logger.warning(f"Could not extract src from photo HTML: {photo_html}")
            except Exception as photo_error:
                logger.error(f"Error extracting photo URL: {photo_error}")
        
        # Если фото нет или произошла ошибка, используем аватар по умолчанию
        avatar_url = f"https://ui-avatars.com/api/?name={user_name}&size=128&background=4E7FFF&color=fff"
        return {
            "photo_url": avatar_url,
            "first_name": user_name,
            "success": True
        }
            
    except Exception as e:
        # Логируем полную ошибку для отладки
        logger.error(f"Error getting photo for {username}: {str(e)}", exc_info=True)
        
        # Возвращаем аватар по умолчанию даже при ошибке
        avatar_url = f"https://ui-avatars.com/api/?name={username}&size=128&background=4E7FFF&color=fff"
        return {
            "photo_url": avatar_url,
            "first_name": username,
            "success": True
        }

# Purchase routes
@app.post("/api/purchase/calculate", response_model=PurchaseCalculateResponse)
async def calculate_purchase(
    purchase_data: PurchaseCalculate,
    storage: Storage = Depends(get_storage)
):
    try:
        # Validate currency
        if purchase_data.currency not in ['stars', 'ton']:
            raise HTTPException(status_code=400, detail="Invalid currency. Must be 'stars' or 'ton'")
        
        prices = {
            "stars": float(await storage.get_cached_setting("stars_price")),
            "ton": await ton_price_service.get_current_ton_price_rub(storage),
        }
        
        # Рассчитываем цену без наценки
        total_price = purchase_data.amount * prices[purchase_data.currency]
        
        # Для звезд добавляем информацию об экономии
        if purchase_data.currency == "stars":
            OFFICIAL_STARS_PRICE = 1.8  # Константа официальной цены
            official_total = purchase_data.amount * OFFICIAL_STARS_PRICE
            savings = official_total - total_price
            savings_percentage = (savings / official_total) * 100 if official_total > 0 else 0
            
            return PurchaseCalculateResponse(
                base_price=f"{total_price:.2f}",
                currency=purchase_data.currency,
                amount=purchase_data.amount,
                official_price=f"{official_total:.2f}",
                savings_amount=f"{savings:.2f}",
                savings_percentage=f"{savings_percentage:.1f}"
            )
        else:
            # Для TON только базовая цена
            return PurchaseCalculateResponse(
                base_price=f"{total_price:.2f}",
                currency=purchase_data.currency,
                amount=purchase_data.amount
            )
            
    except Exception as e:
        logger.error(f"Error calculating price: {e}")
        raise HTTPException(status_code=500, detail="Failed to calculate price")

@app.post("/api/purchase", response_model=PaymentCreateResponse)
async def make_purchase(
    purchase_data: PurchaseRequest,
    current_user: User = Depends(get_authenticated_user),
    storage: Storage = Depends(get_storage)
):
    try:
        # Validate currency
        if purchase_data.currency not in ['stars', 'ton']:
            raise HTTPException(status_code=400, detail="Invalid currency. Must be 'stars' or 'ton'")
        
        # Validate minimum amounts
        min_amounts = {"stars": 50, "ton": 0.1}
        if purchase_data.amount < min_amounts[purchase_data.currency]:
            raise HTTPException(
                status_code=400, 
                detail=f"Minimum amount for {purchase_data.currency} is {min_amounts[purchase_data.currency]}"
            )
        
        robokassa = get_robokassa()
        if not robokassa:
            raise HTTPException(status_code=500, detail="Payment system not configured")
        
        # Get current prices without markup
        prices = {
            "stars": float(await storage.get_cached_setting("stars_price")),
            "ton": await ton_price_service.get_current_ton_price_rub(storage),
        }
        
        # Calculate total price without markup
        calculated_total = purchase_data.amount * prices[purchase_data.currency]
        
        # Verify that the sent rub_amount matches our calculation
        if abs(calculated_total - purchase_data.rub_amount) > 0.01:  # Allow 1 kopeck difference
            raise HTTPException(
                status_code=400, 
                detail=f"Price mismatch. Expected: {calculated_total:.2f}, got: {purchase_data.rub_amount:.2f}"
            )
        
        # Generate unique invoice ID
        import uuid
        invoice_id = str(uuid.uuid4())
        
        # Create transaction record
        transaction_data = TransactionCreate(
            user_id=current_user.id,
            type="purchase",
            currency=purchase_data.currency,
            amount=Decimal(str(purchase_data.amount)),
            rub_amount=Decimal(str(purchase_data.rub_amount)),
            status="pending",
            description=f"Покупка {purchase_data.amount} {purchase_data.currency}",
            payment_system="robokassa",
            invoice_id=invoice_id,
            recipient_username=purchase_data.username,
            ton_price_at_purchase=Decimal(str(prices["ton"])) if purchase_data.currency == "ton" else None
        )
        
        transaction = await storage.create_transaction(transaction_data)
        
        # Create payment URL
        payment_url = robokassa.create_payment_url(
            invoice_id=invoice_id,
            amount=Decimal(str(purchase_data.rub_amount)),
            description=f"Покупка {purchase_data.amount} {purchase_data.currency}",
            user_email=f"{current_user.telegram_id}@telegram.user"
        )
        
        # Update transaction with payment URL
        await storage.update_transaction(transaction.id, {"payment_url": payment_url})
        
        logger.info(f"Created payment for user {current_user.telegram_id}: {purchase_data.rub_amount} RUB for {purchase_data.amount} {purchase_data.currency}")
        
        return PaymentCreateResponse(
            transaction_id=transaction.id,
            payment_url=payment_url,
            invoice_id=invoice_id,
            amount=str(purchase_data.rub_amount),
            status="pending"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error creating payment: {e}")
        raise HTTPException(status_code=500, detail="Failed to create payment")

# Tasks routes
@app.get("/api/tasks", response_model=List[TaskResponse])
async def get_tasks(
    current_user: User = Depends(get_authenticated_user),
    storage: Storage = Depends(get_storage)
):
    try:
        tasks = await storage.get_active_tasks()
        user_tasks = await storage.get_user_tasks(current_user.id)
        user_task_map = {ut.task_id: ut for ut in user_tasks}

        tasks_with_completion = []
        for task in tasks:
            user_task = user_task_map.get(task.id)
            task_dict = task.__dict__
            task_dict['completed'] = user_task.completed if user_task else False
            task_dict['completed_at'] = user_task.completed_at if user_task else None
            tasks_with_completion.append(TaskResponse(**task_dict))

        return tasks_with_completion
    except Exception as e:
        logger.error(f"Error getting tasks: {e}")
        raise HTTPException(status_code=500, detail="Failed to get tasks")

@app.post("/api/tasks/{task_id}/complete")
async def complete_task(
    task_id: str,
    current_user: User = Depends(get_authenticated_user),
    storage: Storage = Depends(get_storage)
):
    try:
        task = await storage.get_task(task_id)
        if not task:
            raise HTTPException(status_code=404, detail="Task not found")
        
        # ✅ ДОБАВИТЬ ПРОВЕРКИ НОВЫХ ПОЛЕЙ (с fallback):
        task_status = getattr(task, 'status', 'active')
        if task_status != "active" or not task.is_active:
            raise HTTPException(status_code=400, detail="Task is not available")
            
        # Проверяем дедлайн (если есть)
        task_deadline = getattr(task, 'deadline', None)
        if task_deadline and datetime.now() > task_deadline:
            raise HTTPException(status_code=400, detail="Task deadline passed")
            
        # Проверяем максимум выполнений (если есть)
        task_max_completions = getattr(task, 'max_completions', None)
        task_completed_count = getattr(task, 'completed_count', 0)
        if task_max_completions and task_completed_count >= task_max_completions:
            raise HTTPException(status_code=400, detail="Task completion limit reached")

        # Проверяем уже выполненное задание
        existing_user_task = await storage.get_user_task(current_user.id, task_id)
        if existing_user_task and existing_user_task.completed:
            raise HTTPException(status_code=400, detail="Task already completed")
        
        # Создаем user_task если не существует
        if not existing_user_task:
            user_task_data = UserTaskCreate(user_id=current_user.id, task_id=task_id)
            await storage.create_user_task(user_task_data)
        
        # Выполняем задание
        completed_task = await storage.complete_user_task(current_user.id, task_id)
        
        # Начисляем награду
        updates = {
            "stars_balance": current_user.stars_balance + task.reward,
            "total_stars_earned": current_user.total_stars_earned + task.reward,
            "tasks_completed": current_user.tasks_completed + 1,
            "daily_earnings": current_user.daily_earnings + task.reward
        }
        await storage.update_user(current_user.id, updates)
        
        # Увеличиваем счетчик выполнений задания (если метод существует)
        try:
            await storage.increment_task_completion_count(task_id)
        except:
            pass  # Игнорируем если метод не существует
        
        # Создаем транзакцию награды
        transaction_data = TransactionCreate(
            user_id=current_user.id,
            type="task_reward",
            currency="stars",
            amount=Decimal(str(task.reward)),
            status="completed",
            description=f"Task reward: {task.title}"
        )
        await storage.create_transaction(transaction_data)
        
        return {"success": True, "reward": task.reward}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error completing task: {e}")
        raise HTTPException(status_code=500, detail="Failed to complete task")

# Заглушки для проверки
async def verify_task_action(action: str, user: User) -> bool:
    """Заглушка проверки выполнения действия"""
    # TODO: реализовать проверки для каждого типа действия
    action_handlers = {
        'daily_login': lambda: True,
        'share_app': lambda: True,
        'follow_channel': lambda: True,
        'invite_friends': lambda: True,
        'complete_purchase': lambda: True,
        'visit_website': lambda: True,
    }
    
    handler = action_handlers.get(action)
    return handler() if handler else True

async def check_task_requirements(user: User, requirements_json: str, storage: Storage) -> bool:
    """Проверка требований для выполнения задания"""
    try:
        if not requirements_json:
            return True
            
        requirements = json.loads(requirements_json)
        
        # Проверка минимального уровня (по количеству выполненных заданий)
        if 'minLevel' in requirements:
            if user.tasks_completed < requirements['minLevel']:
                return False
                
        # Проверка выполненных заданий
        if 'completedTasks' in requirements:
            for required_task_id in requirements['completedTasks']:
                user_task = await storage.get_user_task(user.id, required_task_id)
                if not user_task or not user_task.completed:
                    return False
                    
        return True
    except json.JSONDecodeError:
        return True  # Если JSON невалидный, разрешаем выполнение

@app.get("/api/referrals/stats", response_model=ReferralStats)
@app.get("/api/referrals/stats", response_model=ReferralStats)
async def get_referral_stats_v2(
    current_user: User = Depends(get_authenticated_user),
    storage: Storage = Depends(get_storage)
):
    try:
        logger.info(f"🎯 Getting referral stats for user: {current_user.id} (telegram: {current_user.telegram_id})")
        
        # Получаем всех рефералов пользователя
        referrals = await storage.get_user_referrals(current_user.id)
        
        logger.info(f"🎯 get_user_referrals returned: {len(referrals)} items")
        
        # Формируем список рефералов для ответа
        referral_list = []
        for referral in referrals:
            referral_data = {
                "id": referral.id,
                "username": referral.username or "",
                "first_name": referral.first_name or "",
                "created_at": referral.created_at.isoformat() if referral.created_at else None
            }
            referral_list.append(referral_data)
            logger.info(f"  📋 Added referral: {referral.id} ({referral.username})")
        
        result = ReferralStats(
            total_referrals=len(referral_list),  # Правильный подсчет
            total_earnings=current_user.total_referral_earnings or 0,
            referral_code=current_user.referral_code,
            referrals=referral_list
        )
        
        logger.info(f"🎯 Final result: total_referrals={result.total_referrals}")
        return result
        
    except Exception as e:
        logger.error(f"❌ Error getting referral stats for user {current_user.id}: {e}", exc_info=True)
        
        # Возвращаем пустые данные вместо ошибки
        fallback_result = ReferralStats(
            total_referrals=0,
            total_earnings=current_user.total_referral_earnings or 0,
            referral_code=current_user.referral_code,
            referrals=[]
        )
        logger.info(f"🎯 Returning fallback result: {fallback_result}")
        return fallback_result
    
# Payment webhook and status routes
@app.post("/api/payment/webhook/robokassa")
async def robokassa_webhook(
    request: Request,
    storage: Storage = Depends(get_storage)
):
    """Handle Robokassa payment webhook"""
    try:
        robokassa = get_robokassa()
        if not robokassa:
            raise HTTPException(status_code=500, detail="Payment system not configured")
        
        # Parse form data
        form_data = await request.form()
        webhook_data = dict(form_data)
        
        logger.info(f"Received Robokassa webhook: {webhook_data}")
        
        # Verify signature
        if not robokassa.verify_payment_result(webhook_data):
            logger.error("Invalid Robokassa signature")
            raise HTTPException(status_code=400, detail="Invalid signature")
        
        invoice_id = webhook_data.get('InvId')
        out_sum = webhook_data.get('OutSum')
        
        if not invoice_id:
            raise HTTPException(status_code=400, detail="Missing InvId")
        
        # Find transaction by invoice_id
        from sqlalchemy import select
        from models import Transaction
        
        result = await storage.db.execute(
            select(Transaction).where(Transaction.invoice_id == invoice_id)
        )
        transaction = result.scalar_one_or_none()
        
        if not transaction:
            logger.error(f"Transaction not found for invoice_id: {invoice_id}")
            raise HTTPException(status_code=404, detail="Transaction not found")
        
        # Update transaction status
        updates = {
            "status": "completed",
            "paid_at": datetime.utcnow(),
            "payment_data": json.dumps(webhook_data)
        }
        
        await storage.update_transaction(transaction.id, updates)
        
        # Update user balance
        user = await storage.get_user(transaction.user_id)
        if user and transaction.type in ["buy_stars", "buy_ton"]:
            if transaction.currency == "stars":
                user_updates = {
                    "stars_balance": user.stars_balance + int(transaction.amount),
                    "total_stars_earned": user.total_stars_earned + int(transaction.amount)
                }
                await storage.update_user(user.id, user_updates)
                logger.info(f"Added {transaction.amount} stars to user {user.telegram_id}")
            elif transaction.currency == "ton":
                logger.info(f"TON purchase completed for user {user.telegram_id}: {transaction.amount} TON")
                # TON is sent to Telegram wallet - no balance update needed
            
            logger.info(f"Payment completed for invoice {invoice_id}, amount: {out_sum} RUB")
        
        return {"status": "OK"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error processing webhook: {e}")
        raise HTTPException(status_code=500, detail="Webhook processing failed")

@app.get("/api/payment/status/{transaction_id}", response_model=PaymentStatusResponse)
async def get_payment_status(
    transaction_id: str,
    current_user: User = Depends(get_authenticated_user),
    storage: Storage = Depends(get_storage)
):
    """Get payment status for transaction"""
    try:
        transaction = await storage.get_transaction(transaction_id)
        
        if not transaction:
            raise HTTPException(status_code=404, detail="Transaction not found")
        
        # Check if transaction belongs to current user
        if transaction.user_id != current_user.id:
            raise HTTPException(status_code=403, detail="Access denied")
        
        # If pending and has invoice_id, check with payment system
        if transaction.status == "pending" and transaction.invoice_id:
            robokassa = get_robokassa()
            if robokassa:
                payment_status = await robokassa.check_payment_status(transaction.invoice_id)
                
                if payment_status and payment_status['status'] == 'paid':
                    # Update transaction status
                    updates = {
                        "status": "completed",
                        "paid_at": datetime.utcnow(),
                        "payment_data": payment_status['response']
                    }
                    await storage.update_transaction(transaction.id, updates)
                    
                    # Update user balance
                    if transaction.currency == "stars":
                        user_updates = {
                            "stars_balance": current_user.stars_balance + int(transaction.amount),
                            "total_stars_earned": current_user.total_stars_earned + int(transaction.amount)
                        }
                        await storage.update_user(current_user.id, user_updates)
                    
                    transaction.status = "completed"
                    transaction.paid_at = datetime.utcnow()
        
        return PaymentStatusResponse(
            transaction_id=transaction.id,
            status=transaction.status,
            paid_at=transaction.paid_at
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting payment status: {e}")
        raise HTTPException(status_code=500, detail="Failed to get payment status")

@app.get("/api/admin/stats")
async def get_admin_stats(storage: Storage = Depends(get_storage)):
    try:
        from datetime import datetime, timedelta
        from sqlalchemy import func, and_
        
        # Сегодняшняя дата
        today = datetime.utcnow().date()
        today_start = datetime.combine(today, datetime.min.time())
        today_end = datetime.combine(today, datetime.max.time())
        
        # 1. Всего пользователей
        total_users_result = await storage.db.execute(
            select(func.count(User.id))
        )
        total_users = total_users_result.scalar() or 0
        
        # 2. Продаж сегодня (только completed)
        today_sales_result = await storage.db.execute(
            select(func.coalesce(func.sum(Transaction.rub_amount), 0))
            .where(and_(
                Transaction.status == "completed",
                Transaction.created_at >= today_start,
                Transaction.created_at <= today_end,
                Transaction.type.in_(["buy_stars", "buy_ton"])
            ))
        )
        today_sales = float(today_sales_result.scalar() or 0)
        
        # 3. Активные рефералы (у кого есть приглашенные)
        active_referrals_result = await storage.db.execute(
            select(func.count(func.distinct(User.referred_by)))
            .where(User.referred_by.isnot(None))
        )
        active_referrals = active_referrals_result.scalar() or 0
        
        # 4. Последние 10 транзакций
        recent_transactions_result = await storage.db.execute(
            select(Transaction, User.username)
            .join(User, Transaction.user_id == User.id)
            .where(Transaction.type.in_(["buy_stars", "buy_ton", "referral_bonus"]))
            .order_by(Transaction.created_at.desc())
            .limit(10)
        )
        
        recent_transactions = []
        for transaction, username in recent_transactions_result.all():
            # Простое описание
            if transaction.type == "buy_stars":
                desc = f"Купил {int(transaction.amount)} звезд за ₽{transaction.rub_amount}"
            elif transaction.type == "buy_ton":
                desc = f"Купил {float(transaction.amount)} TON за ₽{transaction.rub_amount}"
            elif transaction.type == "referral_bonus":
                desc = f"Реферальный бонус: {int(transaction.amount)} звезд"
            else:
                desc = transaction.description or "Транзакция"
            
            recent_transactions.append({
                "id": transaction.id,
                "username": username or "Пользователь",
                "description": desc,
                "status": transaction.status,
                "createdAt": transaction.created_at.isoformat()
            })
        
        return {
            "totalUsers": total_users,
            "todaySales": f"{today_sales:.0f}",
            "activeReferrals": active_referrals,
            "recentTransactions": recent_transactions
        }
        
    except Exception as e:
        logger.error(f"Error getting admin stats: {e}", exc_info=True)
        # Возвращаем пустые данные при ошибке
        return {
            "totalUsers": 0,
            "todaySales": "0",
            "activeReferrals": 0,
            "recentTransactions": []
        }

@app.get("/api/ton-price")
async def get_ton_price(storage: Storage = Depends(get_storage)):
    """Получить текущую цену TON в рублях"""
    try:
        price = await ton_price_service.get_current_ton_price_rub(storage)
        return {"price": f"{price:.2f}"}
    except Exception as e:
        logger.error(f"Error getting TON price: {e}")
        # Возвращаем fallback цену в случае ошибки
        fallback_price = await storage.get_cached_setting("ton_fallback_price")
        fallback = float(fallback_price) if fallback_price and fallback_price.strip() else 420.0
        return {"price": f"{fallback:.2f}"}

@app.put("/api/admin/settings")
async def update_admin_settings(
    settings: AdminSettingsUpdate,
    storage: Storage = Depends(get_storage)
):
    try:
        logger.info(f"🔥 Received settings update: {settings}")
        
        # Флаг для отслеживания изменений TON настроек
        ton_settings_changed = False
        
        # Обновляем только те настройки, которые переданы
        if settings.stars_price:
            logger.info(f"✅ Updating stars_price to: {settings.stars_price}")
            await storage.update_setting("stars_price", settings.stars_price)
            
        if settings.bot_base_url:
            logger.info(f"✅ Updating bot_base_url to: {settings.bot_base_url}")
            await storage.update_setting("bot_base_url", settings.bot_base_url)
            
        if settings.referral_prefix:
            logger.info(f"✅ Updating referral_prefix to: {settings.referral_prefix}")
            await storage.update_setting("referral_prefix", settings.referral_prefix)
            
        if settings.referral_bonus_percentage:
            logger.info(f"✅ Updating referral_bonus_percentage to: {settings.referral_bonus_percentage}")
            await storage.update_setting("referral_bonus_percentage", settings.referral_bonus_percentage)
            
        if settings.referral_registration_bonus:
            logger.info(f"✅ Updating referral_registration_bonus to: {settings.referral_registration_bonus}")
            await storage.update_setting("referral_registration_bonus", settings.referral_registration_bonus)
            
        # TON настройки - отслеживаем изменения
        if settings.ton_markup_percentage:
            logger.info(f"✅ Updating ton_markup_percentage to: {settings.ton_markup_percentage}")
            await storage.update_setting("ton_markup_percentage", settings.ton_markup_percentage)
            ton_settings_changed = True
            
        if settings.ton_price_cache_minutes:
            logger.info(f"✅ Updating ton_price_cache_minutes to: {settings.ton_price_cache_minutes}")
            await storage.update_setting("ton_price_cache_minutes", settings.ton_price_cache_minutes)
            ton_settings_changed = True
            
        if settings.ton_fallback_price:
            logger.info(f"✅ Updating ton_fallback_price to: {settings.ton_fallback_price}")
            await storage.update_setting("ton_fallback_price", settings.ton_fallback_price)
            ton_settings_changed = True
        
        # 🚀 АВТООБНОВЛЕНИЕ TON ЦЕНЫ ПРИ ИЗМЕНЕНИИ НАСТРОЕК
        updated_ton_price = None
        if ton_settings_changed:
            try:
                logger.info("🔄 TON settings changed, forcing price update...")
                
                # Очищаем кэш настроек в storage, чтобы получить новые значения
                if hasattr(storage, '_settings_cache'):
                    storage._settings_cache.clear()
                
                # Принудительно обновляем цену TON с новыми настройками
                updated_ton_price = await ton_price_service.force_update_price(storage)
                logger.info(f"✅ TON price auto-updated: {updated_ton_price:.2f} RUB")
                
            except Exception as price_update_error:
                logger.error(f"❌ Failed to auto-update TON price: {price_update_error}")
                # Не прерываем выполнение, так как основные настройки уже сохранены
        
        logger.info("✅ All settings updated successfully")
        
        # Возвращаем результат с информацией об обновлении цены
        result = {"success": True}
        if updated_ton_price is not None:
            result["ton_price_updated"] = True
            result["new_ton_price"] = f"{updated_ton_price:.2f}"
        
        return result
        
    except Exception as e:
        logger.error(f"❌ Error updating settings: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Failed to update settings: {str(e)}")


def verify_task_admin(token: str) -> bool:
    """Проверка токена администратора заданий из .env"""
    admin_tokens = os.getenv('ADMIN_TOKENS', '').split(',')
    logger.info(f"Admin tokens: {admin_tokens}")
    admin_tokens = [t.strip() for t in admin_tokens if t.strip()]  # Убираем пробелы
    return token in admin_tokens

# НОВЫЕ ENDPOINTS для админки заданий:

@app.post("/api/admin/tasks/create")
async def create_task_admin(
    task_data: dict,
    token: str,
    storage: Storage = Depends(get_storage)
):
    """Создание нового задания администратором"""
    if not verify_task_admin(token):
        raise HTTPException(status_code=403, detail="Access denied")
    
    try:
        # ✅ ПРАВИЛЬНАЯ ОБРАБОТКА ДАННЫХ:
        
        # Конвертируем пустые строки в None для опциональных полей
        deadline = task_data.get("deadline")
        if deadline == "" or deadline is None:
            deadline = None
        elif isinstance(deadline, str):
            try:
                # Пытаемся распарсить datetime из строки
                from datetime import datetime
                deadline = datetime.fromisoformat(deadline.replace('Z', '+00:00'))
            except:
                deadline = None
        
        max_completions = task_data.get("maxCompletions")
        if max_completions == "" or max_completions is None:
            max_completions = None
        else:
            try:
                max_completions = int(max_completions)
            except:
                max_completions = None
        
        requirements = task_data.get("requirements") or "{}"
        url = task_data.get("url")
        if url:
            import json
            try:
                req_data = json.loads(requirements) if requirements else {}
            except:
                req_data = {}
            req_data["url"] = url
            requirements = json.dumps(req_data)
        elif requirements == "":
            requirements = None
        # Создаем задание с правильными типами данных
        new_task = await storage.create_task({
            "title": task_data["title"],
            "description": task_data["description"], 
            "reward": int(task_data["reward"]),
            "type": task_data["type"],
            "action": task_data.get("action") or None,
            "status": task_data.get("status", "active"),
            "deadline": deadline,  # None или datetime объект
            "max_completions": max_completions,  # None или int
            "requirements": requirements,  # None или string
            "is_active": bool(task_data.get("isActive", True))
        })
        
        logger.info(f"New task created: {new_task.title}")
        return {"success": True, "task": new_task}
    except Exception as e:
        logger.error(f"Error creating task: {e}")
        raise HTTPException(status_code=500, detail="Failed to create task")

@app.get("/api/tasks/completed")
async def get_user_completed_tasks(
    current_user: User = Depends(get_authenticated_user),
    storage: Storage = Depends(get_storage)
):
    """Получить историю выполненных заданий пользователя"""
    try:
        # Получаем все выполненные задания пользователя
        completed_user_tasks = await storage.get_completed_user_tasks(current_user.id)
        
        # Преобразуем в нужный формат для фронтенда
        completed_tasks_history = []
        for user_task in completed_user_tasks:
            task = await storage.get_task(user_task.task_id)
            if not task:
                continue
                
            # Определяем тип задания на русском
            task_type_map = {
                "daily": "Ежедневное",
                "social": "Социальное", 
                "purchase": "Покупка",
                "referral": "Реферальное",
                "special": "Специальное"
            }
            task_type_text = task_type_map.get(task.type, task.type.capitalize())
            
            # Форматирование даты с русскими месяцами
            month_names = {
                1: "янв", 2: "фев", 3: "мар", 4: "апр", 5: "май", 6: "июн",
                7: "июл", 8: "авг", 9: "сен", 10: "окт", 11: "ноя", 12: "дек"
            }
            completed_date = user_task.completed_at
            formatted_date = f"{completed_date.day} {month_names[completed_date.month]} {completed_date.year}, {completed_date.strftime('%H:%M')}"
            
            completed_tasks_history.append({
                "id": user_task.id,
                "task_id": task.id,
                "title": task.title,
                "description": task.description,
                "reward": task.reward,
                "task_type": task.type,
                "task_type_text": task_type_text,
                "completed_at": user_task.completed_at.isoformat(),
                "completed_at_formatted": formatted_date
            })
        
        # Сортируем по дате выполнения (новые сверху)
        completed_tasks_history.sort(key=lambda x: x["completed_at"], reverse=True)
        
        return {
            "success": True, 
            "completed_tasks": completed_tasks_history,
            "count": len(completed_tasks_history)
        }
        
    except Exception as e:
        logger.error(f"Error getting completed tasks history: {e}")
        raise HTTPException(status_code=500, detail="Failed to get completed tasks history")
    
@app.get("/api/admin/tasks/list")
async def list_tasks_admin(
    token: str,
    storage: Storage = Depends(get_storage)
):
    """Получение списка всех заданий для админки"""
    if not verify_task_admin(token):
        raise HTTPException(status_code=403, detail="Access denied")
    
    tasks = await storage.get_all_tasks_with_stats()
    return tasks

@app.put("/api/admin/tasks/{task_id}")
async def update_task_admin(
    task_id: str,
    task_data: dict,
    token: str,
    storage: Storage = Depends(get_storage)
):
    """Обновление задания"""
    if not verify_task_admin(token):
        raise HTTPException(status_code=403, detail="Access denied")
    
    try:
        # ✅ ПРАВИЛЬНАЯ ОБРАБОТКА ДАННЫХ:
        
        # Конвертируем пустые строки в None
        deadline = task_data.get("deadline")
        if deadline == "" or deadline is None:
            deadline = None
        elif isinstance(deadline, str):
            try:
                from datetime import datetime
                deadline = datetime.fromisoformat(deadline.replace('Z', '+00:00'))
            except:
                deadline = None
        
        max_completions = task_data.get("maxCompletions")
        if max_completions == "" or max_completions is None:
            max_completions = None
        else:
            try:
                max_completions = int(max_completions)
            except:
                max_completions = None
        
        requirements = task_data.get("requirements") or "{}"
        url = task_data.get("url")

        # Если есть URL, добавляем в requirements как JSON
        if url:
            import json
            try:
                req_data = json.loads(requirements) if requirements else {}
            except:
                req_data = {}
            req_data["url"] = url
            requirements = json.dumps(req_data)
        elif requirements == "":
            requirements = None
            
        # Подготавливаем данные для обновления
        update_data = {
            "title": task_data["title"],
            "description": task_data["description"], 
            "reward": int(task_data["reward"]),
            "type": task_data["type"],
            "action": task_data.get("action") or None,
            "status": task_data.get("status", "active"),
            "deadline": deadline,
            "max_completions": max_completions,
            "requirements": requirements,
            "is_active": bool(task_data.get("isActive", True))
        }
        
        updated_task = await storage.update_task(task_id, update_data)
        return {"success": True, "task": updated_task}
    except Exception as e:
        logger.error(f"Error updating task: {e}")
        raise HTTPException(status_code=500, detail="Failed to update task")

@app.delete("/api/admin/tasks/{task_id}")
async def delete_task_admin(
    task_id: str,
    token: str,
    storage: Storage = Depends(get_storage)
):
    """Архивация задания"""
    if not verify_task_admin(token):
        raise HTTPException(status_code=403, detail="Access denied")
    
    await storage.update_task(task_id, {"status": "expired", "is_active": False})
    return {"success": True}

@app.get("/api/admin/settings/current")
async def get_admin_settings(storage: Storage = Depends(get_storage)):
    return {
        "stars_price": await storage.get_cached_setting("stars_price"),
        "ton_markup_percentage": await storage.get_cached_setting("ton_markup_percentage"),
        "ton_price_cache_minutes": await storage.get_cached_setting("ton_price_cache_minutes"), 
        "ton_fallback_price": await storage.get_cached_setting("ton_fallback_price"),
        "referral_registration_bonus": await storage.get_cached_setting("referral_registration_bonus"),
        "bot_base_url": await storage.get_cached_setting("bot_base_url"),
        "referral_prefix": await storage.get_cached_setting("referral_prefix"),
        "referral_bonus_percentage": await storage.get_cached_setting("referral_bonus_percentage"),
    }

@app.get("/api/admin/ton-diagnostics")
async def ton_diagnostics(storage: Storage = Depends(get_storage)):
    """Диагностика TON Price Service"""
    try:
        # Получаем настройки
        cache_minutes = await storage.get_cached_setting("ton_price_cache_minutes")
        markup = await storage.get_cached_setting("ton_markup_percentage") 
        fallback = await storage.get_cached_setting("ton_fallback_price")
        
        # Статус сервиса
        service_status = {
            "last_price": ton_price_service.last_price,
            "last_update": ton_price_service.last_update.isoformat() if ton_price_service.last_update else None,
            "settings": {
                "cache_minutes": cache_minutes,
                "markup_percentage": markup,
                "fallback_price": fallback
            }
        }
        
        # Тестовый запрос цены
        current_price = await ton_price_service.get_current_ton_price_rub(storage)
        
        return {
            "success": True,
            "current_price": current_price,
            "service_status": service_status
        }
        
    except Exception as e:
        logger.error(f"TON diagnostics error: {e}", exc_info=True)
        return {
            "success": False,
            "error": str(e),
            "service_status": {
                "last_price": ton_price_service.last_price,
                "last_update": ton_price_service.last_update.isoformat() if ton_price_service.last_update else None,
            }
        }

@app.post("/api/admin/update-ton-price")
async def force_update_ton_price(storage: Storage = Depends(get_storage)):
    """Принудительно обновить цену TON"""
    try:
        new_price = await ton_price_service.force_update_price(storage)
        logger.info(f"✅ TON price manually updated: {new_price:.2f} RUB")
        return {
            "success": True,
            "new_price": f"{new_price:.2f}",
            "updated_at": datetime.utcnow().isoformat()
        }
    except Exception as e:
        logger.error(f"❌ Failed to update TON price: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to update TON price: {str(e)}")

@app.get("/api/config/referral")
async def get_referral_config(storage: Storage = Depends(get_storage)):
    return {
        "bot_base_url": await storage.get_cached_setting("bot_base_url"),
        "referral_prefix": await storage.get_cached_setting("referral_prefix"),
        "referral_bonus_percentage": int(await storage.get_cached_setting("referral_bonus_percentage"))
    }

@app.get("/api/config/interface-texts")
async def get_interface_texts(storage: Storage = Depends(get_storage)):
    return {
        "copy_success": await storage.get_cached_setting("copy_success"),
        "copy_error": await storage.get_cached_setting("copy_error"),
        "loading": await storage.get_cached_setting("loading"),
        "error": await storage.get_cached_setting("error")
    }

# Функция уведомлений (заглушка)
async def notify_users_new_task(task):
    """Уведомление пользователей о новом задании"""
    # TODO: реализовать уведомления через Telegram бота
    logger.info(f"New task created: {task.title}")
    pass


# Static files for production
if not os.getenv("DEVELOPMENT"):
    app.mount("/", StaticFiles(directory="dist/public", html=True), name="static")
    
    @app.get("/{path:path}")
    async def serve_spa(path: str):
        return FileResponse("dist/public/index.html")

@app.on_event("startup")
async def startup_event():
    await init_db()
    await init_default_data()
    logger.info("Database initialized")
    # Инициализация Fragment API клиента
    logger.info("Starting Fragment API initialization...")
        # Диагностика переменных окружения
    fragment_seed = os.getenv("FRAGMENT_SEED")
    fragment_cookies = os.getenv("FRAGMENT_COOKIE")
    
    logger.info(f"FRAGMENT_SEED length: {len(fragment_seed) if fragment_seed else 'None'}")
    logger.info(f"FRAGMENT_COOKIE length: {len(fragment_cookies) if fragment_cookies else 'None'}")
    try:
        logger.info("🚀 Initializing TON Price Service...")
        async with AsyncSessionLocal() as session:
            storage = Storage(session)
            initial_price = await ton_price_service.get_current_ton_price_rub(storage)
            logger.info(f"✅ TON Price Service initialized with price: {initial_price:.2f} RUB")
    except Exception as e:
        logger.error(f"❌ Failed to initialize TON Price Service: {e}")
    try:
        fragment_seed = os.getenv("FRAGMENT_SEED")
        fragment_cookies = os.getenv("FRAGMENT_COOKIE")
        
        logger.info(f"Fragment seed exists: {bool(fragment_seed)}")
        logger.info(f"Fragment cookies exist: {bool(fragment_cookies)}")
         
        if fragment_seed and fragment_cookies:
            logger.info("Creating Fragment API client...")
            app.state.fragment_api_client = AsyncFragmentAPIClient(
                seed=fragment_seed,
                fragment_cookies=fragment_cookies
            )
            logger.info("Fragment API client initialized successfully")
              
            balance = await app.state.fragment_api_client.get_balance()
            logger.info(f"Fragment API balance: {balance}")
        else:
            logger.warning("Fragment API credentials not found, client not initialized")
            app.state.fragment_api_client = None
            
    except Exception as e:
        logger.error(f"Failed to initialize Fragment API client: {e}", exc_info=True)
        app.state.fragment_api_client = None
    # from bot import main as bot_main
    # # Запуск бота в фоновом режиме
    # await bot_main()
    

@app.on_event("shutdown")
async def shutdown_event():
    # Правильное закрытие Fragment API клиента
    if hasattr(app.state, 'fragment_api_client') and app.state.fragment_api_client:
        try:
            await app.state.fragment_api_client.close()
            logger.info("Fragment API client closed")
        except Exception as e:
            logger.error(f"Error closing Fragment API client: {e}")
    
    # Close database session
    try:
        await AsyncSessionLocal().close()
        logger.info("Database session closed")
    except Exception as e:
        logger.error(f"Error closing database session: {e}")

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", 8000))
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=port,
        reload=True if os.getenv("DEVELOPMENT") else False
    )


================================================================================
FILE: backend\models.py
================================================================================

from sqlalchemy import Column, String, Integer, Numeric, Boolean, DateTime, Text, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from datetime import datetime
import uuid

Base = declarative_base()

def generate_uuid():
    return str(uuid.uuid4())

class User(Base):
    __tablename__ = "users"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    telegram_id = Column(String, nullable=False, unique=True)
    username = Column(String, nullable=True)
    first_name = Column(String, nullable=True)
    last_name = Column(String, nullable=True)
    stars_balance = Column(Integer, default=0)
    ton_balance = Column(Numeric(18, 8), default=0)
    referral_code = Column(String, unique=True, nullable=True)
    referred_by = Column(String, nullable=True)
    total_stars_earned = Column(Integer, default=0)
    total_referral_earnings = Column(Integer, default=0)
    tasks_completed = Column(Integer, default=0)
    daily_earnings = Column(Integer, default=0)
    notifications_enabled = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    transactions = relationship("Transaction", back_populates="user")
    user_tasks = relationship("UserTask", back_populates="user")

class Transaction(Base):
    __tablename__ = "transactions"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("users.id"), nullable=False)
    type = Column(String, nullable=False)  # 'buy_stars', 'buy_ton', 'referral_bonus', 'task_reward'
    currency = Column(String, nullable=False)  # 'stars', 'ton', 'rub'
    amount = Column(Numeric(18, 8), nullable=False)
    rub_amount = Column(Numeric(10, 2), nullable=True)
    status = Column(String, default="pending")  # 'pending', 'completed', 'failed', 'cancelled'
    description = Column(Text, nullable=True)
    
    # 🚀 НОВОЕ ПОЛЕ для правильного расчета прибыли от TON
    ton_price_at_purchase = Column(Numeric(10, 2), nullable=True)  # Цена TON на момент покупки
    
    # Payment system fields
    payment_system = Column(String, nullable=True)  # 'robokassa', 'manual'
    payment_url = Column(Text, nullable=True)  # URL для оплаты
    invoice_id = Column(String, nullable=True, unique=True)  # ID в платежной системе
    payment_data = Column(Text, nullable=True)  # JSON данные от платежной системы
    
    created_at = Column(DateTime, default=datetime.utcnow)
    paid_at = Column(DateTime, nullable=True)  # Время оплаты
    
    # Relationships
    user = relationship("User", back_populates="transactions")

class Task(Base):
    __tablename__ = "tasks"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    title = Column(Text, nullable=False)
    description = Column(Text, nullable=False)
    reward = Column(Integer, nullable=False)
    type = Column(String, nullable=False)  # 'daily', 'social', 'referral'
    action = Column(String, nullable=True)  # 'daily_login', 'share_app', etc.
    is_active = Column(Boolean, default=True)
    completion_title = Column(String, nullable=True)
    completion_text = Column(String, nullable=True)
    share_text = Column(String, nullable=True)
    button_text = Column(String, nullable=True)
    
    # ✅ ДОБАВИТЬ ЭТИ ПОЛЯ:
    status = Column(String, default="active")  # 'draft', 'active', 'paused', 'expired'
    deadline = Column(DateTime, nullable=True)
    max_completions = Column(Integer, nullable=True)
    requirements = Column(Text, nullable=True)
    completed_count = Column(Integer, default=0)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    user_tasks = relationship("UserTask", back_populates="task")

class UserTask(Base):
    __tablename__ = "user_tasks"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    user_id = Column(String, ForeignKey("users.id"), nullable=False)
    task_id = Column(String, ForeignKey("tasks.id"), nullable=False)
    completed = Column(Boolean, default=False)
    completed_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Relationships
    user = relationship("User", back_populates="user_tasks")
    task = relationship("Task", back_populates="user_tasks")

class Setting(Base):
    __tablename__ = "settings"
    
    id = Column(String, primary_key=True, default=generate_uuid)
    key = Column(String, nullable=False, unique=True)
    value = Column(Text, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow)

================================================================================
FILE: backend\robokassa.py
================================================================================

import hashlib
import hmac
import urllib.parse
from typing import Dict, Optional
from decimal import Decimal
import httpx
import os

class RobokassaPayment:
    def __init__(self):
        self.merchant_login = os.getenv('ROBOKASSA_MERCHANT_LOGIN')
        self.password1 = os.getenv('ROBOKASSA_PASSWORD1')  # Для создания платежей
        self.password2 = os.getenv('ROBOKASSA_PASSWORD2')  # Для проверки результата
        self.test_mode = os.getenv('ROBOKASSA_TEST_MODE', 'true').lower() == 'true'
        
        if not all([self.merchant_login, self.password1, self.password2]):
            raise ValueError("Robokassa credentials not configured")
        
        # URLs
        if self.test_mode:
            self.payment_url = "https://auth.robokassa.ru/Merchant/Index.aspx"
            self.api_url = "https://auth.robokassa.ru/Merchant/WebService/Service.asmx"
        else:
            self.payment_url = "https://merchant.roboxchange.com/Index.aspx"
            self.api_url = "https://merchant.roboxchange.com/WebService/Service.asmx"

    def generate_signature(self, values: list, password: str) -> str:
        """Generate MD5 signature for Robokassa"""
        signature_string = ':'.join(str(v) for v in values)
        return hashlib.md5(f"{signature_string}:{password}".encode('utf-8')).hexdigest().lower()

    def create_payment_url(
        self, 
        invoice_id: str, 
        amount: Decimal, 
        description: str,
        user_email: Optional[str] = None,
        currency: str = "RUB"
    ) -> str:
        """Create payment URL for Robokassa"""
        
        # Required parameters
        params = {
            'MerchantLogin': self.merchant_login,
            'OutSum': str(amount),
            'InvId': invoice_id,
            'Description': description,
            'Culture': 'ru'
        }
        
        # Optional parameters
        if user_email:
            params['Email'] = user_email
            
        if self.test_mode:
            params['IsTest'] = '1'
        
        # Generate signature
        signature_values = [
            self.merchant_login,
            amount,
            invoice_id,
            self.password1
        ]
        
        params['SignatureValue'] = self.generate_signature(signature_values, "")
        
        # Build URL
        query_string = urllib.parse.urlencode(params)
        return f"{self.payment_url}?{query_string}"

    def verify_payment_result(self, data: Dict) -> bool:
        """Verify payment result from Robokassa webhook"""
        try:
            out_sum = data.get('OutSum')
            inv_id = data.get('InvId')
            signature = data.get('SignatureValue', '').lower()
            
            # Generate expected signature
            signature_values = [out_sum, inv_id, self.password2]
            expected_signature = self.generate_signature(signature_values, "")
            
            return hmac.compare_digest(signature, expected_signature)
            
        except Exception as e:
            print(f"Error verifying payment: {e}")
            return False

    async def check_payment_status(self, invoice_id: str) -> Optional[Dict]:
        """Check payment status via Robokassa API"""
        try:
            signature_values = [self.merchant_login, invoice_id, self.password2]
            signature = self.generate_signature(signature_values, "")
            
            params = {
                'MerchantLogin': self.merchant_login,
                'InvoiceID': invoice_id,
                'Signature': signature
            }
            
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{self.api_url}/OpStateExt",
                    data=params,
                    timeout=30
                )
                
                if response.status_code == 200:
                    # Parse XML response (simplified)
                    content = response.text
                    if 'State>5<' in content:  # Status 5 = paid
                        return {'status': 'paid', 'response': content}
                    elif 'State>10<' in content:  # Status 10 = cancelled  
                        return {'status': 'cancelled', 'response': content}
                    else:
                        return {'status': 'pending', 'response': content}
                        
            return None
            
        except Exception as e:
            print(f"Error checking payment status: {e}")
            return None

    def get_available_payment_methods(self) -> list:
        """Get available payment methods"""
        return [
            {'code': 'BankCard', 'name': 'Банковская карта'},
            {'code': 'QIWI', 'name': 'QIWI Кошелек'},
            {'code': 'WebMoney', 'name': 'WebMoney'},
            {'code': 'YandexMoney', 'name': 'ЮMoney'},
            {'code': 'Tinkoff', 'name': 'Тинькофф'},
            {'code': 'SberBank', 'name': 'Сбербанк Онлайн'},
        ]

# Global instance
robokassa = None

def get_robokassa():
    """Get Robokassa instance"""
    global robokassa
    if robokassa is None:
        try:
            robokassa = RobokassaPayment()
        except ValueError as e:
            print(f"Warning: Robokassa not configured: {e}")
            robokassa = None
    return robokassa

================================================================================
FILE: backend\run_dev.py
================================================================================

#!/usr/bin/env python3
"""
Development runner script
Runs FastAPI server with hot reload
"""

import os
import uvicorn
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

if __name__ == "__main__":
    # Set development mode
    os.environ["DEVELOPMENT"] = "true"
    
    # Run with hot reload
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=int(os.getenv("PORT", 8000)),
        reload=True,
        reload_dirs=["./"],
        reload_includes=["*.py"]
    )

================================================================================
FILE: backend\schemas.py
================================================================================

from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime
from decimal import Decimal

# User schemas
class UserCreate(BaseModel):
    telegram_id: str
    username: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    referred_by: Optional[str] = None

class UserUpdate(BaseModel):
    username: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    notifications_enabled: Optional[bool] = None

class UserResponse(BaseModel):
    id: str
    telegram_id: str
    username: Optional[str]
    first_name: Optional[str]
    last_name: Optional[str]
    stars_balance: int
    ton_balance: Decimal
    referral_code: Optional[str]
    referred_by: Optional[str]
    total_stars_earned: int
    total_referral_earnings: int
    tasks_completed: int
    daily_earnings: int
    notifications_enabled: bool
    created_at: datetime
    
    class Config:
        from_attributes = True

# Transaction schemas
class TransactionCreate(BaseModel):
    user_id: str
    type: str
    currency: str
    amount: Decimal
    rub_amount: Optional[Decimal] = None
    status: Optional[str] = "pending"
    description: Optional[str] = None
    payment_system: Optional[str] = None
    payment_url: Optional[str] = None
    invoice_id: Optional[str] = None
    ton_price_at_purchase: Optional[Decimal] = None

class TransactionResponse(BaseModel):
    id: str
    user_id: str
    type: str
    currency: str
    amount: Decimal
    rub_amount: Optional[Decimal]
    status: str
    description: Optional[str]
    payment_system: Optional[str]
    payment_url: Optional[str]
    invoice_id: Optional[str]
    created_at: datetime
    paid_at: Optional[datetime]
    
    class Config:
        from_attributes = True

class TransactionHistoryItem(BaseModel):
    id: str
    description: str
    amount: float
    currency: str
    rub_amount: Optional[float] = None
    status: str
    status_text: str
    status_color: str
    icon_type: str
    created_at: str
    created_at_formatted: str
    
    class Config:
        from_attributes = True

class TransactionHistoryResponse(BaseModel):
    success: bool
    transactions: List[TransactionHistoryItem]
    count: int
    
    class Config:
        from_attributes = True

# Completed Tasks History schemas
class CompletedTaskHistoryItem(BaseModel):
    id: str
    task_id: str
    title: str
    description: str
    reward: int
    task_type: str
    task_type_text: str
    completed_at: str
    completed_at_formatted: str
    
    class Config:
        from_attributes = True

class CompletedTasksHistoryResponse(BaseModel):
    success: bool
    completed_tasks: List[CompletedTaskHistoryItem]
    count: int
    
    class Config:
        from_attributes = True

# Task schemas
class TaskCreate(BaseModel):
    title: str
    description: str
    reward: int
    type: str
    action: Optional[str] = None
    is_active: Optional[bool] = True

class TaskResponse(BaseModel):
    id: str
    title: str
    description: str
    reward: int
    type: str
    action: Optional[str]
    is_active: bool
    
    # ✅ ДОБАВИТЬ ЭТИ ПОЛЯ:
    status: Optional[str] = "active"
    deadline: Optional[datetime] = None
    max_completions: Optional[int] = None
    requirements: Optional[str] = None
    completed_count: Optional[int] = 0
    completion_title: Optional[str] = None
    completion_text: Optional[str] = None
    share_text: Optional[str] = None
    button_text: Optional[str] = None
    
    created_at: datetime
    completed: Optional[bool] = False
    completed_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True

# UserTask schemas
class UserTaskCreate(BaseModel):
    user_id: str
    task_id: str
    completed: Optional[bool] = False

class UserTaskResponse(BaseModel):
    id: str
    user_id: str
    task_id: str
    completed: bool
    completed_at: Optional[datetime]
    created_at: datetime
    
    class Config:
        from_attributes = True

# Setting schemas
class SettingCreate(BaseModel):
    key: str
    value: str

class SettingUpdate(BaseModel):
    value: str

class SettingResponse(BaseModel):
    id: str
    key: str
    value: str
    updated_at: datetime
    
    class Config:
        from_attributes = True

# Purchase schemas
class PurchaseCalculate(BaseModel):
    currency: str  # Will validate in endpoint logic
    amount: float = Field(..., gt=0)

class PurchaseCalculateResponse(BaseModel):
    base_price: str  # Цена по вашему курсу (итоговая цена)
    currency: str
    amount: float
    # Только для звезд:
    official_price: Optional[str] = None  # Официальная цена (1.8 * количество)
    savings_amount: Optional[str] = None  # Экономия в рублях
    savings_percentage: Optional[str] = None  # Экономия в процентах

class PurchaseRequest(BaseModel):
    currency: str
    amount: float = Field(..., gt=0)
    rub_amount: float = Field(..., gt=0)
    username: Optional[str] = None  # ← ДОБАВЬ ЭТУ СТРОКУ

class PurchaseResponse(BaseModel):
    transaction: TransactionResponse
    status: str

# Referral schemas
class ReferralStats(BaseModel):
    total_referrals: int
    total_earnings: int
    referral_code: Optional[str]
    referrals: list

# Admin schemas
class AdminStats(BaseModel):
    total_users: int
    today_sales: str
    active_referrals: int
    recent_transactions: list

class AdminSettingsUpdate(BaseModel):
    stars_price: Optional[str] = None
    ton_markup_percentage: Optional[str] = None
    ton_price_cache_minutes: Optional[str] = None
    ton_fallback_price: Optional[str] = None
    referral_registration_bonus: Optional[str] = None
    #markup_percentage: Optional[str] = None
    bot_base_url: Optional[str] = None
    referral_prefix: Optional[str] = None
    referral_bonus_percentage: Optional[str] = None

# Payment schemas
class PaymentCreateResponse(BaseModel):
    transaction_id: str
    payment_url: str
    invoice_id: str
    amount: str
    status: str

class PaymentWebhookData(BaseModel):
    OutSum: str
    InvId: str
    SignatureValue: str
    
class PaymentStatusResponse(BaseModel):
    transaction_id: str
    status: str
    paid_at: Optional[datetime] = None

================================================================================
FILE: backend\storage.py
================================================================================

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, and_, func
from sqlalchemy.orm import selectinload
from models import User, Transaction, Task, UserTask, Setting
from schemas import UserCreate, TransactionCreate, UserTaskCreate, SettingCreate
from typing import Optional, List
from datetime import datetime
import random
import string
from cachetools import TTLCache

class Storage:
    def __init__(self, db: AsyncSession):
        self.db = db
        self._settings_cache = TTLCache(maxsize=100, ttl=3600)
    # User methods
    async def get_user(self, user_id: str) -> Optional[User]:
        result = await self.db.execute(select(User).where(User.id == user_id))
        return result.scalar_one_or_none()

    async def get_user_by_telegram_id(self, telegram_id: str) -> Optional[User]:
        result = await self.db.execute(
            select(User).where(User.telegram_id == telegram_id)
        )
        return result.scalar_one_or_none()
    
    async def get_user_by_username(self, username: str) -> Optional[User]:
        result = await self.db.execute(
            select(User).where(User.username == username)
        )
        return result.scalar_one_or_none()
    
    async def get_user_referrals(self, user_id: str) -> List[User]:
        """Получить всех рефералов конкретного пользователя"""
        try:
            import logging
            logger = logging.getLogger(__name__)
            
            logger.info(f"🔍 Getting referrals for user_id: {user_id}")
            logger.info(f"🔍 user_id type: {type(user_id)}")
            
            # Сначала проверим, есть ли пользователи с заполненным referred_by вообще
            all_users_query = select(User).where(User.referred_by.isnot(None))
            all_with_referrer = await self.db.execute(all_users_query)
            all_referred_users = all_with_referrer.scalars().all()
            
            logger.info(f"🔍 Total users with referrer in DB: {len(all_referred_users)}")
            for user in all_referred_users:
                logger.info(f"  - User {user.id} (telegram: {user.telegram_id}) referred by: {user.referred_by}")
            
            # Теперь ищем конкретных рефералов
            query = select(User).where(User.referred_by == user_id)
            logger.info(f"🔍 Executing query: {query}")
            
            result = await self.db.execute(query)
            referrals = result.scalars().all()
            
            logger.info(f"🔍 Found {len(referrals)} referrals for user {user_id}")
            
            if referrals:
                logger.info(f"🔍 Referral details:")
                for ref in referrals:
                    logger.info(f"  - ID: {ref.id}, telegram_id: {ref.telegram_id}, username: {ref.username}")
            else:
                logger.warning(f"🔍 No referrals found for user_id: {user_id}")
                
            return referrals
            
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"❌ Error in get_user_referrals: {e}", exc_info=True)
            return []
        
    async def create_user(self, user_data: UserCreate) -> User:
        # Генерируем уникальный код (до 10 попыток)
        for _ in range(10):
            referral_code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
            if not await self.get_user_by_referral_code(referral_code):
                break
        else:
            # Fallback на UUID если не получилось
            import uuid
            referral_code = str(uuid.uuid4())[:10].upper()
        
        user = User(
            telegram_id=user_data.telegram_id,
            username=user_data.username,
            first_name=user_data.first_name,
            last_name=user_data.last_name,
            referral_code=referral_code,
            referred_by=user_data.referred_by
        )
        
        self.db.add(user)
        await self.db.commit()
        await self.db.refresh(user)
        return user

    async def update_user(self, user_id: str, updates: dict) -> Optional[User]:
        await self.db.execute(
            update(User).where(User.id == user_id).values(**updates)
        )
        await self.db.commit()
        return await self.get_user(user_id)

    async def get_all_users(self) -> List[User]:
        """Получить всех пользователей из базы данных"""
        try:
            result = await self.db.execute(select(User))
            users = result.scalars().all()
            
            # Убедимся, что возвращаем список объектов User
            # Проверяем, что каждый элемент - это объект User
            validated_users = []
            for user in users:
                if isinstance(user, User):
                    validated_users.append(user)
                else:
                    # Если по какой-то причине получили не объект User, логируем
                    import logging
                    logger = logging.getLogger(__name__)
                    logger.warning(f"Unexpected type in get_all_users: {type(user)}")
            
            return validated_users
        except Exception as e:
            import logging
            logger = logging.getLogger(__name__)
            logger.error(f"Error in get_all_users: {e}", exc_info=True)
            raise

    # Transaction methods
    async def get_transaction(self, transaction_id: str) -> Optional[Transaction]:
        result = await self.db.execute(
            select(Transaction).where(Transaction.id == transaction_id)
        )
        return result.scalar_one_or_none()

    async def get_transactions_by_user_id(self, user_id: str) -> List[Transaction]:
        result = await self.db.execute(
            select(Transaction).where(Transaction.user_id == user_id)
        )
        return result.scalars().all()

    async def create_transaction(self, transaction_data: TransactionCreate) -> Transaction:
        transaction = Transaction(**transaction_data.dict())
        self.db.add(transaction)
        await self.db.commit()
        await self.db.refresh(transaction)
        return transaction

    async def update_transaction(self, transaction_id: str, updates: dict) -> Optional[Transaction]:
        await self.db.execute(
            update(Transaction).where(Transaction.id == transaction_id).values(**updates)
        )
        await self.db.commit()
        return await self.get_transaction(transaction_id)

    async def get_recent_transactions(self, limit: int = 10) -> List[Transaction]:
        result = await self.db.execute(
            select(Transaction)
            .options(selectinload(Transaction.user))
            .order_by(Transaction.created_at.desc())
            .limit(limit)
        )
        return result.scalars().all()

    # Task methods
    async def get_task(self, task_id: str) -> Optional[Task]:
        result = await self.db.execute(
            select(Task).where(Task.id == task_id)
        )
        return result.scalar_one_or_none()

    async def get_all_tasks(self) -> List[Task]:
        result = await self.db.execute(select(Task))
        return result.scalars().all()

    async def get_active_tasks(self) -> List[Task]:
        result = await self.db.execute(select(Task).where(Task.is_active == True))
        return result.scalars().all()

    # ОБНОВИТЬ метод create_task в storage.py:

    async def create_task(self, task_data: dict):
        """Создать новое задание"""
        # ✅ ФИЛЬТРУЕМ И ОЧИЩАЕМ ДАННЫЕ
        clean_data = {}
        
        # Обязательные поля
        clean_data["title"] = task_data["title"]
        clean_data["description"] = task_data["description"]
        clean_data["reward"] = task_data["reward"]
        clean_data["type"] = task_data["type"]
        clean_data["is_active"] = task_data.get("is_active", True)
        
        # Опциональные строковые поля
        if task_data.get("action"):
            clean_data["action"] = task_data["action"]
        if task_data.get("status"):
            clean_data["status"] = task_data["status"]
        if task_data.get("requirements"):
            clean_data["requirements"] = task_data["requirements"]
            
        # Опциональные специальные поля
        if task_data.get("deadline") is not None:
            clean_data["deadline"] = task_data["deadline"]
        if task_data.get("max_completions") is not None:
            clean_data["max_completions"] = task_data["max_completions"]
        if task_data.get("completed_count") is not None:
            clean_data["completed_count"] = task_data["completed_count"]
        
        task = Task(**clean_data)
        self.db.add(task)
        await self.db.commit()
        await self.db.refresh(task)
        return task

    # ТАКЖЕ ОБНОВИТЬ метод update_task:
    async def update_task(self, task_id: str, updates: dict):
        """Обновить задание"""
        # ✅ ФИЛЬТРУЕМ ДАННЫЕ
        clean_updates = {}
        
        # Список разрешенных полей
        allowed_fields = [
            'title', 'description', 'reward', 'type', 'action', 
            'is_active', 'status', 'deadline', 'max_completions', 
            'requirements', 'completed_count'
        ]
        
        for key, value in updates.items():
            if key in allowed_fields:
                # Не добавляем пустые строки для опциональных полей
                if key in ['deadline', 'max_completions', 'requirements', 'action'] and value == "":
                    clean_updates[key] = None
                else:
                    clean_updates[key] = value
        
        if clean_updates:  # Обновляем только если есть валидные поля
            await self.db.execute(
                update(Task).where(Task.id == task_id).values(**clean_updates)
            )
            await self.db.commit()
        
        return await self.get_task(task_id)

    # UserTask methods
    async def get_user_task(self, user_id: str, task_id: str) -> Optional[UserTask]:
        result = await self.db.execute(
            select(UserTask).where(
                and_(UserTask.user_id == user_id, UserTask.task_id == task_id)
            )
        )
        return result.scalar_one_or_none()

    async def get_user_tasks(self, user_id: str) -> List[UserTask]:
        result = await self.db.execute(
            select(UserTask).where(UserTask.user_id == user_id)
        )
        return result.scalars().all()

    async def create_user_task(self, user_task_data: UserTaskCreate) -> UserTask:
        user_task = UserTask(**user_task_data.dict())
        self.db.add(user_task)
        await self.db.commit()
        await self.db.refresh(user_task)
        return user_task

    async def update_user_task(self, user_task_id: str, updates: dict) -> Optional[UserTask]:
        await self.db.execute(
            update(UserTask).where(UserTask.id == user_task_id).values(**updates)
        )
        await self.db.commit()
        result = await self.db.execute(select(UserTask).where(UserTask.id == user_task_id))
        return result.scalar_one_or_none()

    async def complete_user_task(self, user_id: str, task_id: str) -> Optional[UserTask]:
        user_task = await self.get_user_task(user_id, task_id)
        if not user_task or user_task.completed:
            return None

        updates = {
            "completed": True,
            "completed_at": datetime.utcnow()
        }
        
        await self.db.execute(
            update(UserTask)
            .where(and_(UserTask.user_id == user_id, UserTask.task_id == task_id))
            .values(**updates)
        )
        await self.db.commit()
        return await self.get_user_task(user_id, task_id)

    async def get_user_by_referral_code(self, referral_code: str) -> Optional[User]:
        """Найти пользователя по реферальному коду"""
        try:
            result = await self.db.execute(
                select(User).where(User.referral_code == referral_code)
            )
            return result.scalar_one_or_none()
        except Exception as e:
            return None

    async def add_user_stars(self, user_id: str, stars_amount: int) -> Optional[User]:
        """Начислить звезды пользователю"""
        try:
            user = await self.get_user(user_id)
            if not user:
                return None
            
            updates = {
                "stars_balance": user.stars_balance + stars_amount,
                "total_stars_earned": user.total_stars_earned + stars_amount
            }
            
            updated_user = await self.update_user(user_id, updates)
            return updated_user
            
        except Exception as e:
            return None

    async def process_referral_bonus(self, referrer_user_id: str, bonus_amount: int):
        """Начислить реферальный бонус за покупку друга"""
        try:
            referrer = await self.get_user(referrer_user_id)
            if not referrer:
                return
            
            # Начисляем бонус
            updates = {
                "stars_balance": referrer.stars_balance + bonus_amount,
                "total_referral_earnings": referrer.total_referral_earnings + bonus_amount,
                "total_stars_earned": referrer.total_stars_earned + bonus_amount
            }
            
            await self.update_user(referrer_user_id, updates)
            from decimal import Decimal; 
            # Создаем транзакцию для истории
            from schemas import TransactionCreate
            transaction_data = TransactionCreate(
                user_id=referrer_user_id,
                type="referral_bonus",
                currency="stars",
                amount=Decimal(str(bonus_amount)),
                status="completed",
                description=f"Реферальный бонус: {bonus_amount} звезд с покупки друга"
            )
            await self.create_transaction(transaction_data)
            
            
        except Exception as e:
            None
    async def process_referral_registration(self, referrer_user_id: str, new_user_id: str):
        """Обработать регистрацию нового пользователя по реферальной ссылке"""
        try:
            # Получаем бонус за приглашение из настроек
            registration_bonus = await self.get_cached_setting("referral_registration_bonus")
            if not registration_bonus:
                registration_bonus = "25"  # Значение по умолчанию
            
            bonus_amount = int(registration_bonus)
            
            # Начисляем бонус за приглашение
            await self.process_referral_bonus(referrer_user_id, bonus_amount)
            
            
        except Exception as e:
            pass

    async def get_completed_user_tasks(self, user_id: str) -> List[UserTask]:
        """Получить все выполненные задания пользователя"""
        result = await self.db.execute(
            select(UserTask)
            .where(
                and_(
                    UserTask.user_id == user_id,
                    UserTask.completed == True
                )
            )
            .order_by(UserTask.completed_at.desc())
        )
        return result.scalars().all()

    # Setting methods
    async def get_setting(self, key: str) -> Optional[Setting]:
        result = await self.db.execute(select(Setting).where(Setting.key == key))
        return result.scalar_one_or_none()

    async def get_all_settings(self) -> List[Setting]:
        result = await self.db.execute(select(Setting))
        return result.scalars().all()

    async def set_setting(self, setting_data: SettingCreate) -> Setting:
        setting = Setting(**setting_data.dict())
        self.db.add(setting)
        await self.db.commit()
        await self.db.refresh(setting)
        return setting

    async def update_setting(self, key: str, value: str) -> Optional[Setting]:
        await self.db.execute(
            update(Setting)
            .where(Setting.key == key)
            .values(value=value, updated_at=datetime.utcnow())
        )
        await self.db.commit()
        return await self.get_setting(key)
    
    async def get_all_tasks_with_stats(self):
        """Получить все задания со статистикой"""
        result = await self.db.execute(
            select(Task).order_by(Task.created_at.desc())
        )
        tasks = result.scalars().all()
        
        # Добавляем статистику выполнений
        for task in tasks:
            completed_count = await self.db.execute(
                select(func.count(UserTask.id)).where(
                    UserTask.task_id == task.id,
                    UserTask.completed == True
                )
            )
            task.completed_count = completed_count.scalar() or 0
            
        return tasks
    
    async def create_task(self, task_data: dict):
        """Создать новое задание"""
        task = Task(**task_data)
        self.db.add(task)
        await self.db.commit()
        await self.db.refresh(task)
        return task
    
    async def update_task(self, task_id: str, updates: dict):
        """Обновить задание"""
        await self.db.execute(
            update(Task).where(Task.id == task_id).values(**updates)
        )
        await self.db.commit()
        return await self.get_task(task_id)

    async def increment_task_completion_count(self, task_id: str):
        """Увеличить счетчик выполнений задания"""
        await self.db.execute(
            update(Task)
            .where(Task.id == task_id)
            .values(completed_count=Task.completed_count + 1)
        )
        await self.db.commit()

    async def get_cached_setting(self, key: str) -> str:
        if key in self._settings_cache:
            import logging
            logging.info(f"Cache hit for key: {key} with value: {self._settings_cache[key]}")
            return self._settings_cache[key]
            
        setting = await self.get_setting(key)
        value = setting.value if setting else ""
        import logging
        logging.info(f"Cache miss for key: {key}, loading value: {value}")
        self._settings_cache[key] = value
        return value
    
    async def update_setting(self, key: str, value: str):
        import logging
        logging.info(f"Updating setting key: {key} with value: {value}")
        # Найти или создать setting
        result = await self.db.execute(
            select(Setting).where(Setting.key == key)
        )
        setting = result.scalar_one_or_none()
        
        if setting:
            setting.value = value
            setting.updated_at = datetime.utcnow()
        else:
            setting = Setting(key=key, value=value)
            self.db.add(setting)
        
        await self.db.commit()
        
        # Инвалидировать кэш
        if key in self._settings_cache:
            logging.info(f"Invalidating cache for key: {key}")
            del self._settings_cache[key]


================================================================================
FILE: backend\telegram_auth.py
================================================================================

import hmac
import hashlib
import json
from urllib.parse import unquote
from typing import Dict, Optional
import os
from datetime import datetime, timedelta

def validate_telegram_data(init_data: str, bot_token: str) -> Optional[Dict]:
    """
    Validate Telegram WebApp initData
    Returns user data if valid, None if invalid
    """
    try:
        # Parse the init_data
        data_check_string = ""
        data = {}
        
        # Parse query string
        pairs = init_data.split('&')
        hash_value = ""
        
        for pair in pairs:
            if '=' in pair:
                key, value = pair.split('=', 1)
                key = unquote(key)
                value = unquote(value)
                
                if key == 'hash':
                    hash_value = value
                else:
                    data[key] = value
        
        # Create data check string
        sorted_keys = sorted(data.keys())
        data_check_string = '\n'.join([f"{key}={data[key]}" for key in sorted_keys])
        
        # Generate secret key
        secret_key = hmac.new(
            "WebAppData".encode(),
            bot_token.encode(),
            hashlib.sha256
        ).digest()
        
        # Calculate hash
        calculated_hash = hmac.new(
            secret_key,
            data_check_string.encode(),
            hashlib.sha256
        ).hexdigest()
        
        # Compare hashes
        if not hmac.compare_digest(calculated_hash, hash_value):
            return None
        
        # Check auth_date (data should not be older than 24 hours)
        if 'auth_date' in data:
            auth_date = datetime.fromtimestamp(int(data['auth_date']))
            if datetime.now() - auth_date > timedelta(hours=24):
                return None
        
        # Parse user data
        if 'user' in data:
            user_data = json.loads(data['user'])
            return user_data
        
        return None
        
    except Exception as e:
        print(f"Error validating Telegram data: {e}")
        return None

def get_user_from_header(telegram_id: str = None, init_data: str = None) -> Optional[Dict]:
    """
    Get user data from headers - only with valid initData
    """
    bot_token = os.getenv('BOT_TOKEN')

    # Требуем наличие BOT_TOKEN и init_data
    if not bot_token:
        print("BOT_TOKEN not configured")
        return None

    if not init_data:
        print("init_data not provided")
        return None

    # Валидируем init_data
    return validate_telegram_data(init_data, bot_token)

async def get_current_user(storage, telegram_id: str = None, init_data: str = None):
    """
    Get current user from database using Telegram data
    """
    user_data = get_user_from_header(telegram_id, init_data)
    if not user_data:
        return None
    
    user = await storage.get_user_by_telegram_id(str(user_data['id']))
    return user

================================================================================
FILE: backend\ton_price_service.py
================================================================================

import httpx
import logging
from datetime import datetime, timedelta
from typing import Optional

logger = logging.getLogger(__name__)

class TONPriceService:
    def __init__(self):
        self.last_price: Optional[float] = None
        self.last_update: Optional[datetime] = None

    async def get_current_ton_price_rub(self, storage) -> float:
        """Получить текущую цену TON в рублях с наценкой"""
        try:
            # Получаем настройки с обработкой пустых значений
            cache_minutes_str = await storage.get_cached_setting("ton_price_cache_minutes")
            cache_minutes = float(cache_minutes_str) if cache_minutes_str and cache_minutes_str.strip() else 15.0
            
            markup_str = await storage.get_cached_setting("ton_markup_percentage") 
            markup = float(markup_str) if markup_str and markup_str.strip() else 5.0
            
            fallback_str = await storage.get_cached_setting("ton_fallback_price")
            fallback = float(fallback_str) if fallback_str and fallback_str.strip() else 420.0
            
            logger.info(f"🔧 TON настройки: cache_minutes={cache_minutes}, markup={markup}%, fallback={fallback}")
            
            # Проверяем нужно ли обновление кэша
            cache_expiry = timedelta(minutes=cache_minutes)
            need_update = (
                self.last_price is None or 
                self.last_update is None or 
                datetime.utcnow() - self.last_update > cache_expiry
            )
            
            if need_update:
                logger.info("🔄 Обновляем курс TON...")
                await self._update_price_from_api(markup, fallback)
            else:
                logger.info(f"📊 Используем кэшированную цену TON: {self.last_price:.2f} RUB")
            
            return self.last_price if self.last_price else fallback
            
        except Exception as e:
            logger.error(f"❌ Ошибка получения цены TON: {e}")
            fallback_str = await storage.get_cached_setting("ton_fallback_price")
            fallback = float(fallback_str) if fallback_str and fallback_str.strip() else 420.0
            return fallback

    async def force_update_price(self, storage):
        """Принудительно обновить цену TON"""
        markup_str = await storage.get_cached_setting("ton_markup_percentage") 
        markup = float(markup_str) if markup_str and markup_str.strip() else 5.0
        
        fallback_str = await storage.get_cached_setting("ton_fallback_price")
        fallback = float(fallback_str) if fallback_str and fallback_str.strip() else 420.0
        
        await self._update_price_from_api(markup, fallback)
        return self.last_price

    async def _update_price_from_api(self, markup: float, fallback: float):
        """Обновить цену с внешних API"""
        try:
            async with httpx.AsyncClient() as client:
                # Получаем курс TON/USD с Binance
                logger.info("📡 Запрос курса TON/USD...")
                ton_response = await client.get(
                    "https://api.binance.com/api/v3/ticker/price?symbol=TONUSDT", 
                    timeout=10
                )
                
                if ton_response.status_code != 200:
                    raise Exception(f"Binance API error: {ton_response.status_code}")
                    
                ton_usd = float(ton_response.json()["price"])
                logger.info(f"📈 TON/USD: ${ton_usd}")
                
                # Получаем курс USD/RUB
                logger.info("📡 Запрос курса USD/RUB...")
                usd_response = await client.get(
                    "https://api.exchangerate-api.com/v4/latest/USD", 
                    timeout=10
                )
                
                if usd_response.status_code != 200:
                    raise Exception(f"Exchange rate API error: {usd_response.status_code}")
                    
                usd_rub = usd_response.json()["rates"]["RUB"]
                logger.info(f"💱 USD/RUB: {usd_rub}")
                
                # Считаем цену с наценкой
                base_price = ton_usd * usd_rub
                final_price = base_price * (1 + markup / 100)
                
                self.last_price = final_price
                self.last_update = datetime.utcnow()
                
                logger.info(f"✅ TON цена обновлена: {base_price:.2f} RUB + {markup}% = {final_price:.2f} RUB")
                return final_price
                
        except Exception as e:
            logger.error(f"❌ Ошибка обновления курса TON: {e}")
            # В случае ошибки используем fallback, но не обновляем кэш
            if not self.last_price:
                self.last_price = fallback
                logger.info(f"🔄 Используем fallback цену: {fallback} RUB")

# Глобальный экземпляр
ton_price_service = TONPriceService()

================================================================================
FILE: backend\webhooks.py
================================================================================

import os
import logging
import hashlib
import hmac
from typing import Dict, Any
from datetime import datetime
from decimal import Decimal

from fastapi import APIRouter, HTTPException, Request, Depends
from pydantic import BaseModel

from database import AsyncSessionLocal
from storage import Storage
from schemas import FragmentWebhookData, RobokassaWebhookData

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/webhooks")

async def get_storage():
    async with AsyncSessionLocal() as session:
        yield Storage(session)

def verify_robokassa_signature(out_sum: str, inv_id: str, password: str, signature: str) -> bool:
    """Проверить подпись Robokassa"""
    try:
        # Создать строку для подписи
        sign_string = f"{out_sum}:{inv_id}:{password}"
        # Вычислить MD5 хеш
        calculated_signature = hashlib.md5(sign_string.encode()).hexdigest().upper()
        return calculated_signature == signature.upper()
    except Exception as e:
        logger.error(f"Error verifying Robokassa signature: {e}")
        return False

def verify_fragment_signature(data: Dict[str, Any], bot_token: str) -> bool:
    """Проверить подпись Fragment API"""
    try:
        # Fragment API использует HMAC-SHA256 с bot token
        # Конкретная реализация зависит от документации Fragment API
        # Здесь пример проверки
        message = "|".join([str(v) for v in sorted(data.values()) if v is not None])
        expected_signature = hmac.new(
            bot_token.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()
        return expected_signature == data.get("signature", "")
    except Exception as e:
        logger.error(f"Error verifying Fragment signature: {e}")
        return False

@router.post("/robokassa")
async def robokassa_webhook(
    request: Request,
    storage: Storage = Depends(get_storage)
):
    """Обработка webhook от Robokassa"""
    try:
        # Получить данные из формы
        form_data = await request.form()
        webhook_data = RobokassaWebhookData(
            OutSum=form_data.get("OutSum", ""),
            InvId=form_data.get("InvId", ""),
            SignatureValue=form_data.get("SignatureValue", ""),
            PaymentMethod=form_data.get("PaymentMethod"),
            IncCurrLabel=form_data.get("IncCurrLabel")
        )
        
        logger.info(f"Received Robokassa webhook: {webhook_data}")
        
        # Проверить подпись
        password = os.getenv("ROBOKASSA_PASSWORD2", "")
        if not verify_robokassa_signature(
            webhook_data.OutSum,
            webhook_data.InvId,
            password,
            webhook_data.SignatureValue
        ):
            logger.error("Invalid Robokassa signature")
            raise HTTPException(status_code=400, detail="Invalid signature")
        
        # Найти транзакцию
        transaction = await storage.get_transaction(webhook_data.InvId)
        if not transaction:
            logger.error(f"Transaction not found: {webhook_data.InvId}")
            raise HTTPException(status_code=404, detail="Transaction not found")
        
        # Проверить сумму
        expected_amount = float(transaction.rub_amount or 0)
        received_amount = float(webhook_data.OutSum)
        
        if abs(expected_amount - received_amount) > 0.01:  # Допуск 1 копейка
            logger.error(f"Amount mismatch: expected {expected_amount}, received {received_amount}")
            raise HTTPException(status_code=400, detail="Amount mismatch")
        
        # Обновить статус транзакции
        if transaction.status != "completed":
            await storage.update_transaction(transaction.id, {
                "status": "completed",
                "paid_at": datetime.utcnow(),
                "payment_data": webhook_data.dict()
            })
            
            # Начислить валюту пользователю
            if transaction.currency == "ton":
                # Обновить баланс TON
                user = await storage.get_user(transaction.user_id)
                if user:
                    new_balance = user.ton_balance + transaction.amount
                    await storage.update_user(user.id, {"ton_balance": new_balance})
            elif transaction.currency == "stars":
                # Начислить звезды
                await storage.add_user_stars(transaction.user_id, int(transaction.amount))
            
            # Обработать реферальный бонус
            user = await storage.get_user(transaction.user_id)
            if user and user.referred_by:
                bonus_amount = int(float(transaction.amount) * 0.1)  # 10% бонус
                await storage.process_referral_bonus(user.referred_by, bonus_amount)
            
            logger.info(f"Transaction {transaction.id} completed successfully")
        
        return {"status": "OK"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error processing Robokassa webhook: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.post("/fragment")
async def fragment_webhook(
    webhook_data: FragmentWebhookData,
    storage: Storage = Depends(get_storage)
):
    """Обработка webhook от Fragment API"""
    try:
        logger.info(f"Received Fragment webhook: {webhook_data}")
        
        # Проверить подпись (если требуется)
        bot_token = os.getenv("BOT_TOKEN", "")
        # if bot_token and not verify_fragment_signature(webhook_data.dict(), bot_token):
        #     logger.error("Invalid Fragment signature")
        #     raise HTTPException(status_code=400, detail="Invalid signature")
        
        # Найти транзакцию
        transaction = await storage.get_transaction(webhook_data.payment_id)
        if not transaction:
            logger.error(f"Transaction not found: {webhook_data.payment_id}")
            raise HTTPException(status_code=404, detail="Transaction not found")
        
        # Обработать статус платежа
        if webhook_data.status == "completed" and transaction.status != "completed":
            # Проверить количество звезд
            expected_stars = int(transaction.amount)
            received_stars = webhook_data.stars
            
            if expected_stars != received_stars:
                logger.error(f"Stars mismatch: expected {expected_stars}, received {received_stars}")
                raise HTTPException(status_code=400, detail="Stars amount mismatch")
            
            # Обновить статус транзакции
            await storage.update_transaction(transaction.id, {
                "status": "completed",
                "paid_at": datetime.utcnow(),
                "payment_data": webhook_data.dict()
            })
            
            # Начислить звезды пользователю
            await storage.add_user_stars(transaction.user_id, webhook_data.stars)
            
            # Обработать реферальный бонус
            user = await storage.get_user(transaction.user_id)
            if user and user.referred_by:
                bonus_amount = int(webhook_data.stars * 0.1)  # 10% бонус
                await storage.process_referral_bonus(user.referred_by, bonus_amount)
            
            logger.info(f"Fragment transaction {transaction.id} completed successfully")
            
        elif webhook_data.status in ["failed", "cancelled"]:
            # Обновить статус как неудачный
            await storage.update_transaction(transaction.id, {
                "status": webhook_data.status,
                "payment_data": webhook_data.dict()
            })
            logger.info(f"Fragment transaction {transaction.id} {webhook_data.status}")
        
        return {"status": "OK"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error processing Fragment webhook: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@router.get("/test")
async def test_webhook():
    """Тестовый endpoint для проверки работы webhook'ов"""
    return {"status": "Webhook service is running"}

# Функции для создания платежей (будут использованы в main.py)

async def create_robokassa_payment(
    amount: Decimal,
    description: str,
    invoice_id: str
) -> str:
    """Создать платеж в Robokassa и вернуть URL"""
    try:
        # Параметры Robokassa
        merchant_login = os.getenv("ROBOKASSA_LOGIN", "")
        password1 = os.getenv("ROBOKASSA_PASSWORD1", "")
        
        if not merchant_login or not password1:
            raise ValueError("Robokassa credentials not configured")
        
        # Создать подпись
        sign_string = f"{merchant_login}:{amount}:{invoice_id}:{password1}"
        signature = hashlib.md5(sign_string.encode()).hexdigest()
        
        # Создать URL для оплаты
        base_url = "https://auth.robokassa.ru/Merchant/Index.aspx"
        params = {
            "MerchantLogin": merchant_login,
            "OutSum": str(amount),
            "InvId": invoice_id,
            "Description": description,
            "SignatureValue": signature,
            "IsTest": "1" if os.getenv("DEVELOPMENT") else "0"
        }
        
        query_string = "&".join([f"{k}={v}" for k, v in params.items()])
        payment_url = f"{base_url}?{query_string}"
        
        return payment_url
        
    except Exception as e:
        logger.error(f"Error creating Robokassa payment: {e}")
        raise

async def create_fragment_payment(
    stars: int,
    amount: Decimal,
    description: str,
    invoice_id: str
) -> str:
    """Создать платеж в Fragment API и вернуть URL"""
    try:
        # Это упрощенная версия - реальная интеграция потребует API ключи Fragment
        bot_token = os.getenv("BOT_TOKEN", "")
        
        if not bot_token:
            raise ValueError("Bot token not configured")
        
        # В реальной версии здесь будет вызов Fragment API
        # Пока возвращаем тестовый URL
        fragment_url = f"https://fragment.com/pay?stars={stars}&amount={amount}&invoice={invoice_id}"
        
        return fragment_url
        
    except Exception as e:
        logger.error(f"Error creating Fragment payment: {e}")
        raise

================================================================================
FILE: backend\api\fragment.py
================================================================================

import aiohttp
import asyncio
import base64
import logging
from typing import Optional, Dict, Any
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class BuyStarsRequest:
    username: str
    amount: int
    fragment_cookies: str
    seed: str
    show_sender: Optional[bool] = False

@dataclass
class BuyStarsWithoutKYCRequest:
    username: str
    amount: int
    seed: str

@dataclass
class BuyPremiumRequest:
    username: str
    fragment_cookies: str
    seed: str
    duration: int = 3
    show_sender: Optional[bool] = False

@dataclass
class BuyPremiumWithoutKYCRequest:
    username: str
    seed: str
    duration: int = 3

@dataclass
class GetOrdersRequest:
    seed: str
    limit: int = 10
    offset: int = 0

class FragmentAPIError(Exception):
    """Raised when the Fragment API returns an error response."""

    def __init__(self, message):
        self.message = str(message)
        super().__init__(self.message)

    def __str__(self):
        return self.message

class AsyncFragmentAPIClient:
    def __init__(self, seed: str = None, fragment_cookies: str = None, base_url="https://api.fragment-api.net"):
        self.base_url = base_url.rstrip("/")
        self.default_seed = seed
        self.default_fragment_cookies = fragment_cookies
        self._session = None

    async def __aenter__(self):
        """Async context manager entry"""
        timeout = aiohttp.ClientTimeout(total=30, connect=10)
        self._session = aiohttp.ClientSession(timeout=timeout)
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        if self._session:
            await self._session.close()
            self._session = None

    def _get_session(self):
        """Get or create session for standalone usage"""
        if self._session is None:
            timeout = aiohttp.ClientTimeout(total=30, connect=10)
            self._session = aiohttp.ClientSession(timeout=timeout)
        return self._session

    async def close(self):
        """Manually close session"""
        if self._session:
            await self._session.close()
            self._session = None

    async def _get(self, path: str) -> Dict[str, Any]:
        session = self._get_session()
        url = f"{self.base_url}{path}"
        
        try:
            async with session.get(url) as response:
                text = await response.text()
                
                if not response.ok:
                    logger.error(f"GET {url} failed with status {response.status}: {text}")
                    raise FragmentAPIError(f"{response.status} | {text}")
                
                try:
                    return await response.json()
                except Exception as json_error:
                    logger.error(f"Failed to parse JSON response: {json_error}")
                    raise FragmentAPIError(f"Invalid JSON response: {text}")
                    
        except aiohttp.ClientError as e:
            logger.error(f"Network error for GET {url}: {e}")
            raise FragmentAPIError(f"Network error: {str(e)}")
        except asyncio.TimeoutError:
            logger.error(f"Timeout for GET {url}")
            raise FragmentAPIError("Request timeout")

    async def _post(self, path: str, data: Dict[str, Any]) -> Dict[str, Any]:
        session = self._get_session()
        url = f"{self.base_url}{path}"
        
        try:
            # Логируем отправляемые данные (без чувствительной информации)
            safe_data = {k: ("***" if "cookie" in k.lower() or "seed" in k.lower() else v) 
                        for k, v in data.items()}
            logger.debug(f"POST {url} with data: {safe_data}")
            
            async with session.post(url, json=data) as response:
                text = await response.text()
                
                if not response.ok:
                    logger.error(f"POST {url} failed with status {response.status}: {text}")
                    raise FragmentAPIError(f"{response.status} | {text}")
                
                try:
                    json_response = await response.json()
                    logger.debug(f"Response from {url}: {json_response}")
                    return json_response
                except Exception as json_error:
                    logger.error(f"Failed to parse JSON response: {json_error}")
                    raise FragmentAPIError(f"Invalid JSON response: {text}")
                    
        except aiohttp.ClientError as e:
            logger.error(f"Network error for POST {url}: {e}")
            raise FragmentAPIError(f"Network error: {str(e)}")
        except asyncio.TimeoutError:
            logger.error(f"Timeout for POST {url}")
            raise FragmentAPIError("Request timeout")
    
    def _base64_encode(self, data: str) -> str:
        """Безопасное кодирование в base64"""
        try:
            if not isinstance(data, str):
                data = str(data)
            return base64.b64encode(data.encode('utf-8')).decode('utf-8')
        except Exception as e:
            logger.error(f"Error encoding data to base64: {e}")
            raise FragmentAPIError(f"Failed to encode data: {str(e)}")

    def _get_seed(self, seed: str = None) -> str:
        """Получить и валидировать seed"""
        try:
            if seed is None:
                if self.default_seed is None:
                    raise FragmentAPIError("Seed not provided and no default seed set.")
                seed = self.default_seed
            
            if not isinstance(seed, str):
                raise FragmentAPIError("Seed must be a string.")
            
            seed = seed.strip()
            seed_words = seed.split()
            
            if len(seed_words) not in [12, 24]:
                raise FragmentAPIError("Seed must be 12 or 24 space-separated words.")
            
            return self._base64_encode(seed)
            
        except FragmentAPIError:
            raise
        except Exception as e:
            logger.error(f"Error processing seed: {e}")
            raise FragmentAPIError(f"Invalid seed format: {str(e)}")

    def _get_fragment_cookies(self, fragment_cookies: str = None) -> str:
        """Получить и валидировать fragment cookies"""
        try:
            if fragment_cookies is None:
                if self.default_fragment_cookies is None:
                    raise FragmentAPIError("Fragment cookies not provided and no default set.")
                fragment_cookies = self.default_fragment_cookies
            
            if not isinstance(fragment_cookies, str):
                raise FragmentAPIError("Fragment cookies must be a string.")
            
            fragment_cookies = fragment_cookies.strip()
            
            if "stel_ssid=" not in fragment_cookies:
                raise FragmentAPIError("Fragment cookies must contain stel_ssid parameter")
            
            return self._base64_encode(fragment_cookies)
            
        except FragmentAPIError:
            raise
        except Exception as e:
            logger.error(f"Error processing fragment cookies: {e}")
            raise FragmentAPIError(f"Invalid fragment cookies format: {str(e)}")

    async def ping(self) -> Dict[str, Any]:
        """Проверить доступность API"""
        try:
            return await self._get("/ping")
        except Exception as e:
            logger.error(f"Ping failed: {e}")
            raise

    async def get_balance(self, seed: str = None) -> Dict[str, Any]:
        """Получить баланс кошелька"""
        try:
            data = {"seed": self._get_seed(seed)}
            return await self._post("/getBalance", data)
        except Exception as e:
            logger.error(f"Get balance failed: {e}")
            raise

    async def get_user_info(self, username: str, fragment_cookies: str = None) -> Dict[str, Any]:
        """Получить информацию о пользователе"""
        try:
            if not username or not isinstance(username, str):
                raise FragmentAPIError("Username must be a non-empty string")
            
            username = username.strip()
            if not username:
                raise FragmentAPIError("Username cannot be empty")
            
            # Удаляем @ если есть
            if username.startswith('@'):
                username = username[1:]
            
            data = {
                "username": username,
                "fragment_cookies": self._get_fragment_cookies(fragment_cookies)
            }
            
            logger.info(f"Getting user info for username: {username}")
            result = await self._post("/getUserInfo", data)
            
            # Дополнительная валидация ответа
            if not isinstance(result, dict):
                logger.error(f"Invalid response type: {type(result)}")
                raise FragmentAPIError("Invalid response format from API")
            
            return result
            
        except FragmentAPIError:
            raise
        except Exception as e:
            logger.error(f"Get user info failed for {username}: {e}")
            raise FragmentAPIError(f"Failed to get user info: {str(e)}")

    async def buy_stars(self, username: str, amount: int, show_sender: bool = False, 
                       fragment_cookies: str = None, seed: str = None) -> Dict[str, Any]:
        """Купить звезды пользователю (с KYC)"""
        try:
            req_data = {
                "username": username,
                "amount": amount,
                "fragment_cookies": self._get_fragment_cookies(fragment_cookies),
                "seed": self._get_seed(seed),
                "show_sender": show_sender
            }
            return await self._post("/buyStars", req_data)
        except Exception as e:
            logger.error(f"Buy stars failed: {e}")
            raise

    async def buy_stars_without_kyc(self, username: str, amount: int, seed: str = None) -> Dict[str, Any]:
        """Купить звезды пользователю (без KYC)"""
        try:
            req_data = {
                "username": username,
                "amount": amount,
                "seed": self._get_seed(seed)
            }
            return await self._post("/buyStarsWithoutKYC", req_data)
        except Exception as e:
            logger.error(f"Buy stars without KYC failed: {e}")
            raise

    async def buy_premium(self, username: str, duration: int = 3, show_sender: bool = False,
                         fragment_cookies: str = None, seed: str = None) -> Dict[str, Any]:
        """Купить премиум пользователю (с KYC)"""
        try:
            req_data = {
                "username": username,
                "fragment_cookies": self._get_fragment_cookies(fragment_cookies),
                "seed": self._get_seed(seed),
                "duration": duration,
                "show_sender": show_sender
            }
            return await self._post("/buyPremium", req_data)
        except Exception as e:
            logger.error(f"Buy premium failed: {e}")
            raise

    async def buy_premium_without_kyc(self, username: str, duration: int = 3, seed: str = None) -> Dict[str, Any]:
        """Купить премиум пользователю (без KYC)"""
        try:
            if duration not in [3, 6, 12]:
                raise FragmentAPIError("Duration must be 3, 6, or 12 months")
                
            req_data = {
                "username": username,
                "seed": self._get_seed(seed),
                "duration": duration
            }
            return await self._post("/buyPremiumWithoutKYC", req_data)
        except Exception as e:
            logger.error(f"Buy premium without KYC failed: {e}")
            raise

    async def get_orders(self, seed: str = None, limit: int = 10, offset: int = 0) -> Dict[str, Any]:
        """Получить список заказов"""
        try:
            req_data = {
                "seed": self._get_seed(seed),
                "limit": limit,
                "offset": offset
            }
            return await self._post("/getOrders", req_data)
        except Exception as e:
            logger.error(f"Get orders failed: {e}")
            raise

================================================================================
FILE: backend\api\__init__.py
================================================================================

from .fragment import AsyncFragmentAPIClient

================================================================================
FILE: frontend\components.json
================================================================================

{
    "$schema": "https://ui.shadcn.com/schema.json",
    "style": "new-york",
    "rsc": false,
    "tsx": true,
    "tailwind": {
      "config": "tailwind.config.ts",
      "css": "client/src/index.css",
      "baseColor": "neutral",
      "cssVariables": true,
      "prefix": ""
    },
    "aliases": {
      "components": "@/components",
      "utils": "@/lib/utils",
      "ui": "@/components/ui",
      "lib": "@/lib",
      "hooks": "@/hooks"
    }
}

================================================================================
FILE: frontend\drizzle.config.ts
================================================================================

import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});


================================================================================
FILE: frontend\index.html
================================================================================

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
  
  <!-- Google Fonts - Manrope с поддержкой кириллицы -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200;300;400;500;600;700;800&display=swap&subset=latin,cyrillic" rel="stylesheet">
  
  <title>Stars Exchange</title>
</head>

<body>
  <div id="root"></div>
  <script src="https://telegram.org/js/telegram-web-app.js?59"></script>
  <script type="module" src="/src/main.tsx"></script>
</body>

</html>

================================================================================
FILE: frontend\package-lock.json
================================================================================

{
  "name": "rest-express",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {}
}


================================================================================
FILE: frontend\package.json
================================================================================

{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@tanstack/react-query": "^5.60.5",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "date-fns": "^3.6.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.453.0",
    "memorystore": "^1.6.7",
    "nanoid": "^5.1.5",
    "next-themes": "^0.4.6",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.2",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.2.8",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.0",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.16",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "terser": "^5.43.1",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.19"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}

================================================================================
FILE: frontend\parse.py
================================================================================

import os
import pathlib

def export_repo_to_text(root_dir, output_file, include_extensions=None, exclude_dirs=None):
    """Экспортирует код репозитория в текстовый файл"""
    if include_extensions is None:
        include_extensions = ['.py', '.js', '.html', '.css', '.md', '.java', '.c', '.cpp', '.h']
    
    if exclude_dirs is None:
        exclude_dirs = ['.git', '__pycache__', 'node_modules', 'venv', '.venv', 'env', 'dist', 'build']
    
    # Создаем папки для выходного файла если нужно
    os.makedirs(os.path.dirname(output_file), exist_ok=True)
    
    root_dir = pathlib.Path(root_dir).resolve()
    exclude_dirs_set = set(exclude_dirs)

    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(root_dir):
            root_path = pathlib.Path(root)
            
            # Фильтрация директорий (по имени)
            dirs[:] = [d for d in dirs if d not in exclude_dirs_set]
            
            for file in files:
                file_path = root_path / file
                
                # Проверка расширения
                if file_path.suffix not in include_extensions:
                    continue

                # Пропуск если путь содержит исключённую папку (например: .../.venv/...)
                if any(part in exclude_dirs_set for part in file_path.parts):
                    continue
                
                try:
                    # Заголовок файла
                    rel_path = file_path.relative_to(root_dir)
                    outfile.write(f"\n\n{'=' * 80}\n")
                    outfile.write(f"FILE: {rel_path}\n")
                    outfile.write(f"{'=' * 80}\n\n")
                    
                    # Чтение содержимого
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                        
                except UnicodeDecodeError:
                    outfile.write(f"\n\n[BINARY FILE: {rel_path} - SKIPPED]\n")
                except Exception as e:
                    outfile.write(f"\n\n[ERROR READING {rel_path}: {str(e)}]\n")

if __name__ == "__main__":
    REPO_DIR = pathlib.Path(__file__).parent.resolve()
    OUTPUT_PATH = REPO_DIR / "docs/repository_code.txt"
    
    print(f"Старт экспорта репозитория: {REPO_DIR}")
    print(f"Выходной файл: {OUTPUT_PATH}")
    
    export_repo_to_text(
        root_dir=REPO_DIR,
        output_file=str(OUTPUT_PATH),
        include_extensions=[".py", ".js", ".html", ".css", ".md", ".ts", ".json",".tsx",".",".",".",],
        exclude_dirs=[".git", "__pycache__", "venv", ".venv", "env", "dist", "build", "node_modules"]
    )
    
    print(f"Экспорт завершен! Размер файла: {os.path.getsize(OUTPUT_PATH)/1024:.2f} KB")


================================================================================
FILE: frontend\postcss.config.js
================================================================================

export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


================================================================================
FILE: frontend\tailwind.config.ts
================================================================================

import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./index.html", "./src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      // Добавляем Manrope как основной шрифт
      fontFamily: {
        sans: ['Manrope', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'],
        manrope: ['Manrope', 'sans-serif'],
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
        card: {
          DEFAULT: "var(--card)",
          foreground: "var(--card-foreground)",
        },
        popover: {
          DEFAULT: "var(--popover)",
          foreground: "var(--popover-foreground)",
        },
        primary: {
          DEFAULT: "var(--primary)",
          foreground: "var(--primary-foreground)",
        },
        secondary: {
          DEFAULT: "var(--secondary)",
          foreground: "var(--secondary-foreground)",
        },
        muted: {
          DEFAULT: "var(--muted)",
          foreground: "var(--muted-foreground)",
        },
        accent: {
          DEFAULT: "var(--accent)",
          foreground: "var(--accent-foreground)",
        },
        destructive: {
          DEFAULT: "var(--destructive)",
          foreground: "var(--destructive-foreground)",
        },
        border: "var(--border)",
        input: "var(--input)",
        ring: "var(--ring)",
        chart: {
          "1": "var(--chart-1)",
          "2": "var(--chart-2)",
          "3": "var(--chart-3)",
          "4": "var(--chart-4)",
          "5": "var(--chart-5)",
        },
        sidebar: {
          DEFAULT: "var(--sidebar-background)",
          foreground: "var(--sidebar-foreground)",
          primary: "var(--sidebar-primary)",
          "primary-foreground": "var(--sidebar-primary-foreground)",
          accent: "var(--sidebar-accent)",
          "accent-foreground": "var(--sidebar-accent-foreground)",
          border: "var(--sidebar-border)",
          ring: "var(--sidebar-ring)",
        },
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;

================================================================================
FILE: frontend\tsconfig.json
================================================================================

{
  "include": ["src/**/*", "shared/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve", 
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}


================================================================================
FILE: frontend\vite.config.ts
================================================================================

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  plugins: [
    react(),
    // Убираем replit-специфичные плагины для продакшена
    ...(process.env.NODE_ENV === "development" && process.env.REPL_ID
      ? [
        // Эти плагины только для replit разработки
      ]
      : []),
  ],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "src"), // Исправлено для новой структуры
    },
  },
  // Убираем root, так как теперь мы в папке frontend
  build: {
    outDir: "dist", // Исправлено - относительный путь
    emptyOutDir: true,
    sourcemap: false,

    // ИСПРАВЛЕНИЕ: Заменяем terser на esbuild - быстрее и стабильнее
    minify: "esbuild",

    // Добавляем оптимизации для предотвращения зависания
    target: 'es2015',
    chunkSizeWarningLimit: 1000,

    // rollupOptions: {
    //   // Ограничиваем параллельные операции для стабильности
    //   maxParallelFileOps: 1,

    //   output: {
    //     // Разделяем большие библиотеки в отдельные chunks
    //     manualChunks: (id) => {
    //       if (id.includes('node_modules')) {
    //         // Группируем vendor библиотеки
    //         if (id.includes('react') || id.includes('react-dom')) {
    //           return 'react-vendor';
    //         }
    //         if (id.includes('@radix-ui')) {
    //           return 'ui-vendor';
    //         }
    //         return 'vendor';
    //       }
    //     },

    //     // Оптимизируем имена файлов
    //     chunkFileNames: (chunkInfo) => {
    //       const facadeModuleId = chunkInfo.facadeModuleId
    //         ? chunkInfo.facadeModuleId.split('/').pop()
    //         : 'chunk';
    //       return `${facadeModuleId}-[hash].js`;
    //     }
    //   }
    // }
  },
  server: {
    host: true,
    port: 5173,
    proxy: {
      "/api": {
        target: "http://localhost:8000",
        changeOrigin: true,
      },
    },
  },

  // Оптимизируем предварительную сборку зависимостей
  optimizeDeps: {
    include: ['react', 'react-dom'],
    // Исключаем проблемные пакеты
    exclude: ['@esbuild-kit/esm-loader', '@esbuild-kit/core-utils']
  }
});

================================================================================
FILE: frontend\shared\schema.ts
================================================================================

import { sql } from "drizzle-orm";
import { pgTable, text, varchar, integer, decimal, boolean, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  telegramId: varchar("telegram_id").notNull().unique(),
  username: text("username"),
  firstName: text("first_name"),
  lastName: text("last_name"),
  starsBalance: integer("stars_balance").default(0),
  tonBalance: decimal("ton_balance", { precision: 18, scale: 8 }).default("0"),
  referralCode: varchar("referral_code").unique(),
  referredBy: varchar("referred_by"),
  totalStarsEarned: integer("total_stars_earned").default(0),
  totalReferralEarnings: integer("total_referral_earnings").default(0),
  tasksCompleted: integer("tasks_completed").default(0),
  dailyEarnings: integer("daily_earnings").default(0),
  notificationsEnabled: boolean("notifications_enabled").default(true),
  createdAt: timestamp("created_at").defaultNow(),
});

// Add foreign key after table definition
export const usersRelations = {
  referredBy: users.referredBy
};

export const transactions = pgTable("transactions", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").references(() => users.id).notNull(),
  type: varchar("type").notNull(), // 'buy_stars', 'buy_ton', 'referral_bonus', 'task_reward'
  currency: varchar("currency").notNull(), // 'stars', 'ton', 'rub'
  amount: decimal("amount", { precision: 18, scale: 8 }).notNull(),
  rubAmount: decimal("rub_amount", { precision: 10, scale: 2 }),
  status: varchar("status").default("pending"), // 'pending', 'completed', 'failed'
  description: text("description"),
  createdAt: timestamp("created_at").defaultNow(),
});

export const tasks = pgTable("tasks", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  title: text("title").notNull(),
  description: text("description").notNull(),
  reward: integer("reward").notNull(),
  type: varchar("type").notNull(), // 'daily', 'social', 'referral'
  action: varchar("action"), // + новые: 'invite_friends', 'complete_purchase', 'visit_website'
  isActive: boolean("is_active").default(true),
  
  // НОВЫЕ ПОЛЯ:
  status: varchar("status").default("active"), // 'draft', 'active', 'paused', 'expired'
  deadline: timestamp("deadline"), // срок выполнения (опционально)
  maxCompletions: integer("max_completions"), // максимум выполнений (опционально)
  requirements: text("requirements"), // требования в JSON формате (опционально)
  completedCount: integer("completed_count").default(0), // счетчик выполнений
  completionTitle: text("completion_title"),
  completionText: text("completion_text"),
  shareText: text("share_text"),
  buttonText: text("button_text"),
  createdAt: timestamp("created_at").defaultNow(),
});

export const userTasks = pgTable("user_tasks", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").references(() => users.id).notNull(),
  taskId: varchar("task_id").references(() => tasks.id).notNull(),
  completed: boolean("completed").default(false),
  completedAt: timestamp("completed_at"),
  createdAt: timestamp("created_at").defaultNow(),
});

export const settings = pgTable("settings", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  key: varchar("key").notNull().unique(),
  value: text("value").notNull(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true,
});

export const insertTransactionSchema = createInsertSchema(transactions).omit({
  id: true,
  createdAt: true,
});

export const insertTaskSchema = createInsertSchema(tasks).omit({
  id: true,
  createdAt: true,
});

export const insertUserTaskSchema = createInsertSchema(userTasks).omit({
  id: true,
  createdAt: true,
  completedAt: true,
});

export const insertSettingSchema = createInsertSchema(settings).omit({
  id: true,
  updatedAt: true,
});

export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;
export type Transaction = typeof transactions.$inferSelect;
export type InsertTransaction = z.infer<typeof insertTransactionSchema>;
export type Task = typeof tasks.$inferSelect;
export type InsertTask = z.infer<typeof insertTaskSchema>;
export type UserTask = typeof userTasks.$inferSelect;
export type InsertUserTask = z.infer<typeof insertUserTaskSchema>;
export type Setting = typeof settings.$inferSelect;
export type InsertSetting = z.infer<typeof insertSettingSchema>;


================================================================================
FILE: frontend\src\App.tsx
================================================================================

import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import Home from "@/pages/home";
import AdminPage from "@/pages/admin";
import NotFound from "@/pages/not-found";
import TaskAdminPage from "@/components/task-admin-page";

function Router() {
  return (
    <Switch>
      <Route path="/" component={Home} />
      <Route path="/admin" component={AdminPage} />
      <Route path="/edittasks" component={TaskAdminPage} />
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
        <Toaster />
        <Router />
      </TooltipProvider>
    </QueryClientProvider>
  );
}

export default App;


================================================================================
FILE: frontend\src\index.css
================================================================================

@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;

    /* App-specific custom properties */
    --app-bg-dark: hsl(240, 4%, 6%);
    --app-card-dark: hsl(240, 4%, 11%);
    --app-accent-blue: hsl(221, 83%, 53%);
    --app-success: hsl(142, 76%, 36%);
    --app-warning: hsl(38, 92%, 50%);
    --app-error: hsl(0, 84%, 60%);
    
    /* Sidebar colors */
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
    
    /* Dark theme sidebar colors */
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 94.1%;
    --sidebar-primary-foreground: 240 5.9% 10%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
  
  /* Применяем Manrope ко всем элементам */
  * {
    @apply border-border;
    font-family: 'Manrope', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }
  
  body {
    @apply bg-background text-foreground;
    font-family: 'Manrope', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-feature-settings: 'rlig' 1, 'calt' 1;
  }

  /* Улучшенная типографика для Manrope */
  h1, h2, h3, h4, h5, h6 {
    font-family: 'Manrope', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-weight: 600;
    letter-spacing: -0.025em;
  }
  
  .text-balance {
    text-wrap: balance;
  }
  
  /* Enhanced focus styles */
  .dark :focus-visible {
    outline: 2px solid hsl(var(--ring));
    outline-offset: 2px;
    box-shadow: 0 0 0 2px hsl(var(--background)), 0 0 0 4px hsl(var(--ring)), 0 0 0 1px rgba(255, 255, 255, 0.05);
  }
  
  .skeleton {
    background: linear-gradient(90deg, hsl(240, 4%, 11%) 25%, hsl(240, 4%, 16%) 50%, hsl(240, 4%, 11%) 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
  }
  
  @keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }
  
  .animate-fade-in {
    animation: fade-in 0.2s ease-out;
  }
  
  .animate-slide-up {
    animation: slide-up 0.2s ease-out;
  }
  
  .animate-pulse-glow {
    animation: pulse-glow 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }
  
  @keyframes fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes slide-up {
    from { 
      opacity: 0; 
      transform: translateY(20px); 
    }
    to { 
      opacity: 1; 
      transform: translateY(0); 
    }
  }
  
  @keyframes pulse-glow {
    0%, 100% { 
      box-shadow: 0 0 20px rgba(78, 127, 255, 0.3);
    }
    50% { 
      box-shadow: 0 0 30px rgba(78, 127, 255, 0.6);
    }
  }
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
  
  /* App-specific utility classes */
  .bg-app-dark {
    background-color: var(--app-bg-dark);
  }
  
  .bg-app-card-dark {
    background-color: var(--app-card-dark);
  }
  
  .text-app-accent {
    color: var(--app-accent-blue);
  }
  
  .bg-app-accent {
    background-color: var(--app-accent-blue);
  }
  
  .border-app-accent {
    border-color: var(--app-accent-blue);
  }
  
  .text-app-success {
    color: var(--app-success);
  }
  
  .text-app-warning {
    color: var(--app-warning);
  }
  
  .text-app-error {
    color: var(--app-error);
  }
  
  /* Дополнительные font-weight утилиты для Manrope */
  .font-extralight {
    font-weight: 200;
  }
  
  .font-light {
    font-weight: 300;
  }
  
  .font-normal {
    font-weight: 400;
  }
  
  .font-medium {
    font-weight: 500;
  }
  
  .font-semibold {
    font-weight: 600;
  }
  
  .font-bold {
    font-weight: 700;
  }
  
  .font-extrabold {
    font-weight: 800;
  }
}

/* Custom scrollbar for dark theme */
.dark ::-webkit-scrollbar {
  width: 6px;
}

.dark ::-webkit-scrollbar-track {
  background: hsl(240, 4%, 11%);
}

.dark ::-webkit-scrollbar-thumb {
  background: hsl(240, 4%, 25%);
  border-radius: 3px;
}

.dark ::-webkit-scrollbar-thumb:hover {
  background: hsl(240, 4%, 35%);
}

================================================================================
FILE: frontend\src\main.tsx
================================================================================

import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";

createRoot(document.getElementById("root")!).render(<App />);


================================================================================
FILE: frontend\src\components\admin-panel.tsx
================================================================================

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import {
  Shield,
  X,
  BarChart3,
  Tag,
  History,
  Users,
  DollarSign,
  Activity,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

interface AdminPanelProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function AdminPanel({ isOpen, onClose }: AdminPanelProps) {
  const [starsPrice, setStarsPrice] = useState("");
  const [tonPrice, setTonPrice] = useState("");
  const [markupPercentage, setMarkupPercentage] = useState("");
  const [botBaseUrl, setBotBaseUrl] = useState("");
  const [referralPrefix, setReferralPrefix] = useState("");
  const [referralBonusPercentage, setReferralBonusPercentage] = useState("");

  const { toast } = useToast();
  const queryClient = useQueryClient();

  const { data: adminStats } = useQuery({
    queryKey: ["/api/admin/stats"],
    enabled: isOpen,
    queryFn: async () => {
      const response = await apiRequest("GET", "/api/admin/stats");
      return response.json();
    },
  });

  const { data: currentSettings } = useQuery({
    queryKey: ["/api/admin/settings/current"],
    enabled: isOpen,
    queryFn: async () => {
      const response = await apiRequest("GET", "/api/admin/settings/current");
      return response.json();
    },
  });

  useEffect(() => {
    if (currentSettings) {
      setStarsPrice(currentSettings.stars_price || "");
      setTonPrice(currentSettings.ton_price || "");
      setMarkupPercentage(currentSettings.markup_percentage || "");
      setBotBaseUrl(currentSettings.bot_base_url || "");
      setReferralPrefix(currentSettings.referral_prefix || "");
      setReferralBonusPercentage(currentSettings.referral_bonus_percentage || "");
    }
  }, [currentSettings]);

  const updateSettingsMutation = useMutation({
    mutationFn: async (settings: {
      starsPrice: string;
      tonPrice: string;
      markupPercentage: string;
      botBaseUrl: string;
      referralPrefix: string;
      referralBonusPercentage: string;
    }) => {
      const response = await apiRequest("PUT", "/api/admin/settings", {
        stars_price: settings.starsPrice,
        ton_price: settings.tonPrice,
        markup_percentage: settings.markupPercentage,
        bot_base_url: settings.botBaseUrl,
        referral_prefix: settings.referralPrefix,
        referral_bonus_percentage: settings.referralBonusPercentage,
      });
      return response.json();
    },
    onSuccess: () => {
      toast({
        title: "Настройки обновлены",
        description: "Цены успешно обновлены",
      });
      queryClient.invalidateQueries({ queryKey: ["/api/admin/stats"] });
      queryClient.invalidateQueries({ queryKey: ["/api/admin/settings/current"] });
    },
    onError: () => {
      toast({
        title: "Ошибка",
        description: "Не удалось обновить настройки",
        variant: "destructive",
      });
    },
  });

  const handleUpdatePrices = () => {
    updateSettingsMutation.mutate({
      starsPrice,
      tonPrice,
      markupPercentage,
      botBaseUrl,
      referralPrefix,
      referralBonusPercentage,
    });
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-50">
          <motion.div
            className="absolute inset-0 bg-black/50 backdrop-blur-sm"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
          />
          <motion.div
            className="absolute bottom-0 left-0 right-0 bg-white dark:bg-[#1A1A1C] rounded-t-2xl p-6 max-h-[80vh] overflow-y-auto shadow-2xl"
            initial={{ y: "100%" }}
            animate={{ y: 0 }}
            exit={{ y: "100%" }}
            transition={{ type: "spring", damping: 25, stiffness: 500 }}
          >
            <div className="flex items-center justify-between mb-6">
              <h2 className="text-xl font-bold flex items-center">
                <Shield className="w-5 h-5 text-[#4E7FFF] mr-2" />
                Админ панель
              </h2>
              <Button
                onClick={onClose}
                variant="ghost"
                size="icon"
                className="hover:bg-gray-100 dark:hover:bg-white/10"
              >
                <X className="w-4 h-4" />
              </Button>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {/* Statistics */}
              <motion.div
                className="bg-gray-50 dark:bg-[#0E0E10] rounded-xl p-4"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.1 }}
              >
                <h3 className="font-semibold mb-3 flex items-center">
                  <BarChart3 className="w-4 h-4 text-green-500 mr-2" />
                  Статистика
                </h3>
                <div className="space-y-3">
                  <div className="flex justify-between">
                    <span className="text-gray-600 dark:text-gray-400 flex items-center">
                      <Users className="w-4 h-4 mr-1" />
                      Пользователей
                    </span>
                    <span className="font-semibold">
                      {adminStats?.totalUsers || 0}
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-600 dark:text-gray-400 flex items-center">
                      <DollarSign className="w-4 h-4 mr-1" />
                      Продаж сегодня
                    </span>
                    <span className="font-semibold text-green-500">
                      ₽{adminStats?.todaySales || 0}
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-600 dark:text-gray-400 flex items-center">
                      <Activity className="w-4 h-4 mr-1" />
                      Активных рефералов
                    </span>
                    <span className="font-semibold">
                      {adminStats?.activeReferrals || 0}
                    </span>
                  </div>
                </div>
              </motion.div>

              {/* Price Management */}
              <motion.div
                className="bg-gray-50 dark:bg-[#0E0E10] rounded-xl p-4"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.2 }}
              >
                <h3 className="font-semibold mb-3 flex items-center">
                  <Tag className="w-4 h-4 text-yellow-500 mr-2" />
                  Управление ценами
                </h3>
                <div className="space-y-3">
                  <div>
                    <Label className="text-sm text-gray-600 dark:text-gray-400">
                      Цена за звезду (₽)
                    </Label>
                    <Input
                      type="number"
                      value={starsPrice}
                      onChange={(e) => setStarsPrice(e.target.value)}
                      step="0.01"
                      className="mt-1 bg-white dark:bg-[#1A1A1C] border-gray-200 dark:border-white/20"
                    />
                  </div>
                  <div>
                    <Label className="text-sm text-gray-600 dark:text-gray-400">
                      Цена за TON (₽)
                    </Label>
                    <Input
                      type="number"
                      value={tonPrice}
                      onChange={(e) => setTonPrice(e.target.value)}
                      step="0.01"
                      className="mt-1 bg-white dark:bg-[#1A1A1C] border-gray-200 dark:border-white/20"
                    />
                  </div>
                  <div>
                    <Label className="text-sm text-gray-600 dark:text-gray-400">
                      Наценка (%)
                    </Label>
                    <Input
                      type="number"
                      value={markupPercentage}
                      onChange={(e) => setMarkupPercentage(e.target.value)}
                      step="0.1"
                      className="mt-1 bg-white dark:bg-[#1A1A1C] border-gray-200 dark:border-white/20"
                    />
                  </div>
                  <Button
                    onClick={handleUpdatePrices}
                    disabled={updateSettingsMutation.isPending}
                    className="w-full bg-[#4E7FFF] hover:bg-[#3D6FFF] text-white"
                  >
                    {updateSettingsMutation.isPending
                      ? "Обновляется..."
                      : "Обновить цены"}
                  </Button>
                </div>
              </motion.div>

              {/* Referral Settings */}
              <motion.div
                className="bg-gray-50 dark:bg-[#0E0E10] rounded-xl p-4 md:col-span-2"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.25 }}
              >
                <h3 className="font-semibold mb-3 flex items-center">
                  <Shield className="w-4 h-4 text-blue-500 mr-2" />
                  Реферальные настройки
                </h3>
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <Label>URL бота</Label>
                    <Input
                      value={botBaseUrl}
                      onChange={(e) => setBotBaseUrl(e.target.value)}
                      placeholder="https://t.me/bot_name"
                    />
                  </div>
                  <div>
                    <Label>Префикс реферальных ссылок</Label>
                    <Input
                      value={referralPrefix}
                      onChange={(e) => setReferralPrefix(e.target.value)}
                      placeholder="ref"
                    />
                  </div>
                  <div className="col-span-2">
                    <Label>Процент реферального бонуса (%)</Label>
                    <Input
                      type="number"
                      value={referralBonusPercentage}
                      onChange={(e) => setReferralBonusPercentage(e.target.value)}
                      placeholder="10"
                    />
                  </div>
                </div>
              </motion.div>

              {/* Recent Transactions */}
              <motion.div
                className="bg-gray-50 dark:bg-[#0E0E10] rounded-xl p-4 md:col-span-2"
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: 0.3 }}
              >
                <h3 className="font-semibold mb-3 flex items-center">
                  <History className="w-4 h-4 text-[#4E7FFF] mr-2" />
                  Последние транзакции
                </h3>
                <div className="space-y-2 max-h-60 overflow-y-auto">
                  {adminStats?.recentTransactions?.length ? (
                    adminStats.recentTransactions.map((transaction: any) => (
                      <div
                        key={transaction.id}
                        className="flex items-center justify-between py-2 border-b border-gray-200 dark:border-white/10 last:border-b-0"
                      >
                        <div>
                          <p className="font-medium">{transaction.username}</p>
                          <p className="text-gray-600 dark:text-gray-400 text-sm">
                            {transaction.description}
                          </p>
                        </div>
                        <div className="text-right">
                          <p
                            className={`font-medium ${
                              transaction.status === "completed"
                                ? "text-green-500"
                                : transaction.status === "failed"
                                ? "text-red-500"
                                : "text-yellow-500"
                            }`}
                          >
                            {transaction.status === "completed"
                              ? "Успешно"
                              : transaction.status === "failed"
                              ? "Ошибка"
                              : "В обработке"}
                          </p>
                          <p className="text-gray-600 dark:text-gray-400 text-xs">
                            {new Date(transaction.createdAt).toLocaleTimeString(
                              "ru-RU",
                              {
                                hour: "2-digit",
                                minute: "2-digit",
                              }
                            )}
                          </p>
                        </div>
                      </div>
                    ))
                  ) : (
                    <p className="text-gray-500 dark:text-gray-400 text-center py-4">
                      Транзакций пока нет
                    </p>
                  )}
                </div>
              </motion.div>
            </div>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
}

================================================================================
FILE: frontend\src\components\balance-card.tsx
================================================================================

import React from "react";
import { motion } from "framer-motion";
import { useQuery } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { Star } from "@/components/ui/custom-icons";
import ButtonWithdrawal from "./ui/button-withdrawal"; // Обновленный импорт
import { useToast } from "@/hooks/use-toast";
import type { SnakeCaseUser } from "@shared/schema";

interface BalanceCardProps {
  user?: SnakeCaseUser;
}

export default function BalanceCard({ user }: BalanceCardProps) {
  const { toast } = useToast();
  const starsBalance = user?.stars_balance ?? 0;

  // ✅ Получаем актуальные цены из API
  const { data: adminSettings } = useQuery({
    queryKey: ['/api/admin/settings/current'],
    queryFn: async () => {
      const response = await apiRequest('GET', '/api/admin/settings/current');
      return response.json();
    },
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    refetchInterval: 10000, // Каждые 10 секунд
  });

  // ✅ Динамический расчет с fallback
  const starsPrice = adminSettings?.stars_price ? parseFloat(adminSettings.stars_price) : 2.30;
  const totalRubValue = starsBalance * starsPrice;

  return (
    <motion.div
      className="mx-4 mb-6"
      initial={{ opacity: 0, y: -20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.5 }}
    >
      <div className="bg-gradient-to-br from-[#4E7FFF] to-purple-500 rounded-2xl p-6 text-white shadow-xl">
        <motion.h2
          className="text-lg font-semibold mb-4"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.1 }}
        >
          Мой баланс
        </motion.h2>
        
        <div className="space-y-4">
          <div className="flex items-center justify-center">
            <div className="flex items-center">
              <div>
                <motion.span
                  className="text-3xl font-bold"
                  key={starsBalance}
                  initial={{ scale: 1 }}
                  animate={{ scale: [1, 1.1, 1] }}
                  transition={{ duration: 0.3 }}
                >
                  {starsBalance.toLocaleString()}
                </motion.span>
              </div>
              <Star className="w-6 h-6 text-yellow-300 mr-3" />
              {/* <p className="text-gray-200 text-sm ml-2">Telegram Stars</p> */}
            </div>
          </div>
          
          <motion.div
            className="mt-4 pt-4 border-t border-white/10 flex items-center justify-between"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.2 }}
          >
            <div className="text-center">
              <p className="text-gray-200 text-xs">Стоимость звезд</p>
              <motion.p
                className="text-lg font-semibold"
                key={totalRubValue}
                initial={{ scale: 1 }}
                animate={{ scale: [1, 1.05, 1] }}
                transition={{ duration: 0.3 }}
              >
                ₽{totalRubValue.toLocaleString()}
              </motion.p>
              {/* <div className="text-xs text-gray-200 mt-1">
                {starsBalance.toLocaleString()} × ₽{starsPrice} за звезду
              </div> */}
            </div>
            <ButtonWithdrawal
              onClick={() => {
                toast({
                  title: "Вывод",
                  description: "Функция вывода звезд в разработке",
                });
              }}
            />
          </motion.div>
        </div>
      </div>
    </motion.div>
  );
}

================================================================================
FILE: frontend\src\components\buy-tab.tsx
================================================================================

import { useState, useEffect, useRef } from "react";
import { motion } from "framer-motion";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useTelegram } from "@/hooks/use-telegram";
import { Star, Bitcoin, ShoppingCart, Calculator, ExternalLink } from "@/components/ui/custom-icons";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import type { SnakeCaseUser, User } from "@shared/schema";
import { PaymentMethodModal } from "@/components/payment-method-modal";

interface BuyTabProps {
 user?: SnakeCaseUser;
 onShowLoading: (message: string) => void;
 onHideLoading: () => void;
}

type Currency = 'stars' | 'ton';

interface PaymentResponse {
 transaction_id: string;
 payment_url: string;
 invoice_id: string;
 amount: string;
 status: string;
}

interface PriceCalculation {
  base_price: string;
  currency: string;
  amount: number;
  // Только для звезд:
  official_price?: string;
  savings_amount?: string;
  savings_percentage?: string;
}

export default function BuyTab({ user, onShowLoading, onHideLoading }: BuyTabProps) {
 const [selectedCurrency, setSelectedCurrency] = useState<Currency>('stars');
 const [amount, setAmount] = useState('');
 const [isProcessing, setIsProcessing] = useState(false);
 const [recipientUsername, setRecipientUsername] = useState('');
 const [userPhoto, setUserPhoto] = useState<{photo_url: string, first_name: string} | null>(null);
 const [userError, setUserError] = useState('');
 const [isLoadingPhoto, setIsLoadingPhoto] = useState(false);
 const { toast } = useToast();
 const { hapticFeedback } = useTelegram();
 const queryClient = useQueryClient();
 const timeoutRef = useRef<NodeJS.Timeout>();
 const [isPaymentModalOpen, setIsPaymentModalOpen] = useState(false);

 const fetchUserPhoto = async (username: string) => {
   setIsLoadingPhoto(true);
   try {
     const response = await fetch(`/api/getPhoto?username=${username}`);
     const data = await response.json();
     
     if (data.success) {
       setUserPhoto(data);
       setUserError('');
     } else {
       setUserError(data.error === "Service temporarily unavailable" 
         ? "Сервис временно недоступен" 
         : "Пользователь не найден");
     }
   } catch {
     setUserError('Пользователь не найден');
   } finally {
     setIsLoadingPhoto(false);
   }
 };

 useEffect(() => {
   if (timeoutRef.current) clearTimeout(timeoutRef.current);
   
   if (!recipientUsername) {
     setUserPhoto(null);
     setUserError('');
     setIsLoadingPhoto(false);
     return;
   }
   
   if (recipientUsername.length >= 1) {
     timeoutRef.current = setTimeout(() => {
       fetchUserPhoto(recipientUsername.trim());
     }, 500);
   }
   
   return () => {
     if (timeoutRef.current) clearTimeout(timeoutRef.current);
   };
 }, [recipientUsername]);

 // Calculate price
 const { data: priceCalculation } = useQuery<PriceCalculation>({
   queryKey: ['/api/purchase/calculate', selectedCurrency, amount],
   enabled: !!amount && parseFloat(amount) > 0,
   queryFn: async () => {
     const response = await apiRequest('POST', '/api/purchase/calculate', {
       currency: selectedCurrency,
       amount: parseFloat(amount),
     });
     return response.json();
   },
    refetchOnWindowFocus: true,
    refetchOnMount: true,
    refetchInterval: 10000, // Каждые 10 секунд
 });

 // Purchase mutation
 const purchaseMutation = useMutation({
   mutationFn: async (data: { currency: string; amount: number; rub_amount: number }) => {
     const response = await apiRequest('POST', '/api/purchase', data);
     return response.json() as Promise<PaymentResponse>;
   },
   onSuccess: (paymentData) => {
     window.open(paymentData.payment_url, '_blank');
     pollPaymentStatus(paymentData.transaction_id);
     toast({
       title: "Переходим к оплате",
       description: "Откройте новую вкладку для оплаты",
     });
   },
   onError: (error: any) => {
     console.error('Purchase error:', error);
     toast({
       title: "Ошибка создания платежа",
       description: "Произошла ошибка при создании ссылки на оплату",
       variant: "destructive",
     });
   },
 });

 // Poll payment status
 const pollPaymentStatus = async (transactionId: string) => {
   setIsProcessing(true);
   onShowLoading('Ожидаем оплату...');

   const maxAttempts = 30;
   let attempts = 0;

   const checkStatus = async () => {
     try {
       const response = await apiRequest('GET', `/api/payment/status/${transactionId}`);
       const statusData = await response.json();

       if (statusData.status === 'completed') {
         queryClient.invalidateQueries({ queryKey: ['/api/users/me'] });
         setAmount('');
         onHideLoading();
         setIsProcessing(false);

         hapticFeedback('success');
         toast({
           title: "Оплата успешна!",
           description: `${selectedCurrency === 'stars' ? 'Звезды' : 'TON'} добавлены на ваш счет`,
         });
         return;
       }

       if (statusData.status === 'failed' || statusData.status === 'cancelled') {
         onHideLoading();
         setIsProcessing(false);
         hapticFeedback('error');
         toast({
           title: "Оплата отменена",
           description: "Платеж был отменен или не удался",
           variant: "destructive",
         });
         return;
       }

       attempts++;
       if (attempts < maxAttempts) {
         setTimeout(checkStatus, 10000);
       } else {
         onHideLoading();
         setIsProcessing(false);
         toast({
           title: "Время ожидания истекло",
           description: "Проверьте статус платежа позже",
           variant: "destructive",
         });
       }
     } catch (error) {
       console.error('Error checking payment status:', error);
       attempts++;
       if (attempts < maxAttempts) {
         setTimeout(checkStatus, 10000);
       } else {
         onHideLoading();
         setIsProcessing(false);
       }
     }
   };

   setTimeout(checkStatus, 5000);
 };

 const handleCurrencySelect = (currency: Currency) => {
   hapticFeedback('light');
   setSelectedCurrency(currency);
   
   // Сбрасываем amount при смене валюты, чтобы избежать некорректных значений
   const currentAmount = parseFloat(amount);
   const minAmounts = { stars: 50, ton: 0.1 };
   
   if (amount && currentAmount < minAmounts[currency]) {
     setAmount('');
   }
 };

 const handleQuickBuy = (quickAmount: number) => {
   hapticFeedback('light');
   setAmount(quickAmount.toString());
 };

  const handleOpenPaymentModal = () => {
    if (!amount || parseFloat(amount) <= 0 || !priceCalculation || isProcessing || !recipientUsername.trim()) return;
    hapticFeedback('light');
    setIsPaymentModalOpen(true);
  };

  const handleSBPPayment = async () => {
    setIsPaymentModalOpen(false);
    hapticFeedback('medium');

    try {
      await purchaseMutation.mutateAsync({
        currency: selectedCurrency,
        amount: parseFloat(amount),
        rub_amount: parseFloat(priceCalculation?.base_price || '0'),
        username: userPhoto ? recipientUsername : undefined,
      });
    } catch (error) {
      // Error handling is done in onError callback
    }
  };

  const { data: adminSettings } = useQuery({
    queryKey: ['/api/admin/settings/current'],
    queryFn: async () => {
      const response = await apiRequest('GET', '/api/admin/settings/current');
      return response.json();
    },
  });

  const { data: tonPriceData } = useQuery({
    queryKey: ['/api/ton-price'],
    queryFn: async () => {
      const response = await apiRequest('GET', '/api/ton-price');
      return response.json();
    },
    refetchInterval: 60000, // Обновляем каждую минуту
    staleTime: 30000,
  });

  const prices = {
    stars: adminSettings?.stars_price ? parseFloat(adminSettings.stars_price) : 2.30,
    ton: tonPriceData?.price ? parseFloat(tonPriceData.price) : 0,
  };

 const quickBuyOptions = selectedCurrency === 'stars'
   ? [100, 500, 1000, 2500]
   : [0.1, 0.5, 1, 2.5];

 return (
   <div className="space-y-4">
     {/* Currency Selector */}
     <motion.div
       className="bg-white dark:bg-[#1A1A1C] rounded-xl p-4 shadow-lg dark:shadow-[0_4px_20px_rgba(0,0,0,0.3)] border border-gray-200 dark:border-white/10"
       initial={{ opacity: 0, y: 20 }}
       animate={{ opacity: 1, y: 0 }}
       transition={{ duration: 0.3 }}
     >
       <h3 className="text-lg font-semibold mb-4 flex items-center">
         <Calculator className="w-5 h-5 mr-2 text-[#4E7FFF]" />
         Выберите валюту
       </h3>
       <div className="grid grid-cols-2 gap-3">
         <motion.button
           onClick={() => handleCurrencySelect('stars')}
           className={`p-4 rounded-xl border-2 transition-all ${selectedCurrency === 'stars'
               ? 'border-[#4E7FFF] bg-[#4E7FFF]/10'
               : 'border-gray-200 dark:border-white/10 hover:border-[#4E7FFF]/50'
             }`}
           whileHover={{ scale: 1.02 }}
           whileTap={{ scale: 0.98 }}
           disabled={isProcessing}
         >
           <Star className="w-8 h-8 text-yellow-500 mx-auto mb-2" />
           <p className="font-semibold">Telegram Stars</p>
           <p className="text-gray-600 dark:text-gray-400 text-xs">₽{prices.stars} за звезду</p>
         </motion.button>
          <motion.button
            onClick={() => handleCurrencySelect('ton')}
            className={`p-4 rounded-xl border-2 transition-all ${selectedCurrency === 'ton'
                ? 'border-[#4E7FFF] bg-[#4E7FFF]/10'
                : 'border-gray-200 dark:border-white/10 hover:border-[#4E7FFF]/50'
              }`}
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
            disabled={isProcessing}
          >
            <div className="w-8 h-8 text-blue-500 mx-auto mb-2 font-bold text-lg">₿</div>
            <p className="font-semibold">TON Coin</p>
            <p className="text-gray-600 dark:text-gray-400 text-xs">
              {tonPriceData?.price ? `₽${parseFloat(tonPriceData.price).toFixed(2)} за TON` : 'Загрузка...'}
            </p>
          </motion.button>
       </div>
     </motion.div>

     {/* Purchase Calculator */}
     <motion.div
       className="bg-white dark:bg-[#1A1A1C] rounded-xl p-4 shadow-lg dark:shadow-[0_4px_20px_rgba(0,0,0,0.3)] border border-gray-200 dark:border-white/10"
       initial={{ opacity: 0, y: 20 }}
       animate={{ opacity: 1, y: 0 }}
       transition={{ duration: 0.3, delay: 0.1 }}
     >
       <h3 className="text-lg font-semibold mb-4 flex items-center">
         <ShoppingCart className="w-5 h-5 mr-2 text-[#4E7FFF]" />
         Калькулятор покупки
       </h3>
       
       <div className="space-y-4">
         {/* Username Input */}
         <div>
           <div className="flex items-center justify-between mb-2">
             <Label className="text-gray-600 dark:text-gray-400">
               Получатель
             </Label>
             <Button
               type="button"
               variant="ghost"
               size="sm"
               onClick={() => {
                 if (user?.username) {
                   setRecipientUsername(user.username);
                   setUserPhoto(null);
                   setUserError('');
                 }
               }}
               className="text-xs h-6 px-2"
             >
               Мой @
             </Button>
           </div>
           
           {userPhoto ? (
             <div className="flex items-center p-3 bg-gray-50 dark:bg-[#0E0E10] rounded-lg border">
               <img 
                 src={userPhoto.photo_url} 
                 alt="Avatar" 
                 className="w-8 h-8 rounded-full mr-3"
                 onError={() => setUserPhoto(null)}
               />
               <span className="font-medium">{userPhoto.first_name}</span>
               <Button
                 type="button"
                 variant="ghost"
                 size="sm"
                 onClick={() => {
                   setUserPhoto(null);
                   setRecipientUsername('');
                   setUserError('');
                 }}
                 className="ml-auto text-xs h-6 px-2"
               >
                 ×
               </Button>
             </div>
           ) : (
             <div>
               <Input
                 value={recipientUsername}
                 onChange={(e) => {
                   setRecipientUsername(e.target.value);
                   setUserError('');
                 }}
                 onKeyDown={(e) => {
                   if (e.key === 'Enter' && recipientUsername.trim()) {
                     if (timeoutRef.current) clearTimeout(timeoutRef.current);
                     fetchUserPhoto(recipientUsername.trim());
                   }
                 }}
                 placeholder="Введите @username"
                 className={`bg-white dark:bg-[#1A1A1C] border-gray-200 dark:border-white/20 ${
                   userError ? 'border-red-500' : ''
                 }`}
               />
               {(userError || isLoadingPhoto) && (
                 <p className={`text-sm mt-1 ${isLoadingPhoto ? 'text-gray-500' : 'text-red-500'}`}>
                   {isLoadingPhoto ? 'Загрузка...' : userError}
                 </p>
               )}
             </div>
           )}
         </div>

         {/* Amount Input */}
         <div>
           <Label className="text-gray-600 dark:text-gray-400">
             Количество {selectedCurrency === 'stars' ? 'звезд' : 'TON'}
           </Label>
           <Input
             type="number"
             value={amount}
             onChange={(e) => setAmount(e.target.value)}
             placeholder={`От ${selectedCurrency === 'stars' ? '50' : '0.1'}`}
             min={selectedCurrency === 'stars' ? 50 : 0.1}
             step={selectedCurrency === 'stars' ? 1 : 0.1}
             className="mt-1 bg-white dark:bg-[#1A1A1C] border-gray-200 dark:border-white/20"
             disabled={isProcessing}
           />
         </div>

         {/* Price Display */}
         {priceCalculation && (
           <motion.div
             className="bg-gradient-to-r from-[#4E7FFF]/10 to-purple-500/10 rounded-lg p-4 border border-white/10"
             initial={{ opacity: 0, scale: 0.95 }}
             animate={{ opacity: 1, scale: 1 }}
             transition={{ duration: 0.3 }}
           >
             {selectedCurrency === 'stars' ? (
               // Отображение для звезд с экономией
               <>
                 {priceCalculation.official_price && (
                   <div className="flex justify-between items-center mb-2">
                     <span className="text-gray-600 dark:text-gray-400">Стоимость:</span>
                     <span className="font-semibold line-through text-red-500">
                       ₽{parseFloat(priceCalculation.official_price).toLocaleString()}
                     </span>
                   </div>
                 )}
                 {priceCalculation.savings_amount && (
                   <div className="flex justify-between items-center mb-2">
                     <span className="text-gray-600 dark:text-gray-400">Скидка:</span>
                     <span className="font-semibold text-green-500">
                       ₽{parseFloat(priceCalculation.savings_amount).toLocaleString()}
                     </span>
                   </div>
                 )}
                 <hr className="border-gray-200 dark:border-white/10 my-2" />
                 <div className="flex justify-between items-center">
                   <span className="font-semibold">Итого:</span>
                   <motion.span
                     className="font-bold text-lg text-[#4E7FFF]"
                     initial={{ scale: 1 }}
                     animate={{ scale: [1, 1.05, 1] }}
                     transition={{ duration: 0.3 }}
                   >
                     ₽{parseFloat(priceCalculation.base_price).toLocaleString()}
                   </motion.span>
                 </div>
               </>
             ) : (
               // Отображение для TON - только стоимость и итого
               <>
                 <div className="flex justify-between items-center mb-2">
                   <span className="text-gray-600 dark:text-gray-400">Стоимость:</span>
                   <span className="font-semibold">₽{parseFloat(priceCalculation.base_price).toLocaleString()}</span>
                 </div>
                 <hr className="border-gray-200 dark:border-white/10 my-2" />
                 <div className="flex justify-between items-center">
                   <span className="font-semibold">Итого:</span>
                   <motion.span
                     className="font-bold text-lg text-[#4E7FFF]"
                     initial={{ scale: 1 }}
                     animate={{ scale: [1, 1.05, 1] }}
                     transition={{ duration: 0.3 }}
                   >
                     ₽{parseFloat(priceCalculation.base_price).toLocaleString()}
                   </motion.span>
                 </div>
               </>
             )}
           </motion.div>
         )}

         {/* Purchase Button */}
         <Button
           onClick={handleOpenPaymentModal}
           disabled={!amount || parseFloat(amount) <= 0 || !priceCalculation || isProcessing || !recipientUsername.trim()}
           className="w-full bg-[#4E7FFF] hover:bg-[#3D6FFF] text-white font-semibold py-3 transition-all disabled:opacity-50"
           size="lg"
         >
           {isProcessing ? (
             <>
               <div className="animate-spin w-4 h-4 mr-2 border-2 border-white border-t-transparent rounded-full" />
               Ожидаем оплату...
             </>
           ) : purchaseMutation.isPending ? (
             <>
               <div className="animate-spin w-4 h-4 mr-2 border-2 border-white border-t-transparent rounded-full" />
               Создание платежа...
             </>
           ) : (
             <>
               <ExternalLink className="w-4 h-4 mr-2" />
               Выбрать способ оплаты
             </>
           )}
         </Button>
       </div>
     </motion.div>

     {/* Quick Buy Options */}
     <motion.div
       className="bg-white dark:bg-[#1A1A1C] rounded-xl p-4 shadow-lg dark:shadow-[0_4px_20px_rgba(0,0,0,0.3)] border border-gray-200 dark:border-white/10"
       initial={{ opacity: 0, y: 20 }}
       animate={{ opacity: 1, y: 0 }}
       transition={{ duration: 0.3, delay: 0.2 }}
     >
       <h3 className="text-lg font-semibold mb-4">Быстрая покупка</h3>
       <div className="grid grid-cols-2 gap-3">
         {quickBuyOptions.map((optionAmount) => (
           <motion.button
             key={optionAmount}
             onClick={() => handleQuickBuy(optionAmount)}
             className="p-3 rounded-lg bg-gray-50 dark:bg-[#0E0E10] hover:bg-[#4E7FFF]/20 border border-gray-200 dark:border-white/10 hover:border-[#4E7FFF] transition-all disabled:opacity-50"
             whileHover={{ scale: 1.02 }}
             whileTap={{ scale: 0.98 }}
             disabled={isProcessing}
           >
             <div className="text-center">
               <p className="font-semibold">
                 {optionAmount} {selectedCurrency === 'stars' ? '⭐' : '₿'}
               </p>
               <p className="text-gray-600 dark:text-gray-400 text-sm">
                 ₽{(optionAmount * prices[selectedCurrency] * 1.05).toLocaleString()}
               </p>
             </div>
           </motion.button>
         ))}
       </div>
     </motion.div>
     
     {/* Payment Method Modal */}
     <PaymentMethodModal
       isOpen={isPaymentModalOpen}
       onClose={() => setIsPaymentModalOpen(false)}
       onSelectSBP={handleSBPPayment}
       isLoading={purchaseMutation.isPending || isProcessing}
     />
   </div>
 );
}

================================================================================
FILE: frontend\src\components\loading-modal.tsx
================================================================================

import { motion, AnimatePresence } from "framer-motion";
import { Loader2 } from "lucide-react";

interface LoadingModalProps {
  isOpen: boolean;
  message?: string;
}

export default function LoadingModal({ isOpen, message = "Загрузка..." }: LoadingModalProps) {
  return (
    <AnimatePresence>
      {isOpen && (
        <div className="fixed inset-0 z-50">
          <motion.div
            className="absolute inset-0 bg-black/50 backdrop-blur-sm"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          />
          <motion.div
            className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white dark:bg-[#1A1A1C] rounded-2xl p-8 text-center shadow-2xl max-w-sm w-full mx-4"
            initial={{ opacity: 0, scale: 0.8, y: -50 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.8, y: -50 }}
            transition={{ type: "spring", damping: 25, stiffness: 500 }}
          >
            <motion.div
              className="w-12 h-12 mx-auto mb-4"
              animate={{ rotate: 360 }}
              transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
            >
              <Loader2 className="w-12 h-12 text-[#4E7FFF]" />
            </motion.div>
            <h3 className="text-lg font-semibold mb-2">Обработка платежа</h3>
            <motion.p 
              className="text-gray-600 dark:text-gray-400"
              key={message}
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.3 }}
            >
              {message}
            </motion.p>
          </motion.div>
        </div>
      )}
    </AnimatePresence>
  );
}


================================================================================
FILE: frontend\src\components\payment-method-modal.tsx
================================================================================

import React from 'react';
import { motion } from 'framer-motion';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Smartphone, CreditCard, Bitcoin, ArrowLeft } from 'lucide-react';

interface PaymentMethodModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSelectSBP: () => void;
  isLoading?: boolean;
}

export function PaymentMethodModal({ isOpen, onClose, onSelectSBP, isLoading = false }: PaymentMethodModalProps) {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-md bg-white dark:bg-[#1A1A1C] border-gray-200 dark:border-white/10">
        <DialogHeader>
          <DialogTitle className="text-xl font-semibold text-center">
            Выберите способ оплаты
          </DialogTitle>
        </DialogHeader>
        
        <div className="space-y-3 mt-4">
          {/* СБП */}
          <motion.button
            onClick={onSelectSBP}
            disabled={isLoading}
            className="w-full p-4 rounded-xl border-2 border-[#4E7FFF] bg-[#4E7FFF]/10 hover:bg-[#4E7FFF]/20 transition-all flex items-center space-x-4"
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
          >
            <div className="w-12 h-12 bg-[#4E7FFF] rounded-lg flex items-center justify-center">
              <Smartphone className="w-6 h-6 text-white" />
            </div>
            <div className="flex-1 text-left">
              <h3 className="font-semibold">Система быстрых платежей</h3>
              <p className="text-sm text-gray-600 dark:text-gray-400">Мгновенный перевод через банк</p>
            </div>
          </motion.button>

          {/* Банковская карта */}
          <motion.div
            className="w-full p-4 rounded-xl border-2 border-gray-300 dark:border-white/20 bg-gray-100 dark:bg-gray-800/50 opacity-60 flex items-center space-x-4"
            whileHover={{ scale: 1.01 }}
          >
            <div className="w-12 h-12 bg-gray-400 rounded-lg flex items-center justify-center">
              <CreditCard className="w-6 h-6 text-white" />
            </div>
            <div className="flex-1 text-left">
              <h3 className="font-semibold">Банковская карта</h3>
              <p className="text-sm text-gray-500">Скоро будет доступно</p>
            </div>
          </motion.div>

          {/* Криптовалюта */}
          <motion.div
            className="w-full p-4 rounded-xl border-2 border-gray-300 dark:border-white/20 bg-gray-100 dark:bg-gray-800/50 opacity-60 flex items-center space-x-4"
            whileHover={{ scale: 1.01 }}
          >
            <div className="w-12 h-12 bg-gray-400 rounded-lg flex items-center justify-center">
              <Bitcoin className="w-6 h-6 text-white" />
            </div>
            <div className="flex-1 text-left">
              <h3 className="font-semibold">Криптовалюта</h3>
              <p className="text-sm text-gray-500">Скоро будет доступно</p>
            </div>
          </motion.div>
        </div>

        {/* Кнопка назад */}
        <Button
          variant="outline"
          onClick={onClose}
          className="w-full mt-4"
          disabled={isLoading}
        >
          <ArrowLeft className="w-4 h-4 mr-2" />
          Назад
        </Button>
      </DialogContent>
    </Dialog>
  );
}

================================================================================
FILE: frontend\src\components\profile-tab.tsx
================================================================================

import { useState } from "react";
import { motion } from "framer-motion";
import { useQuery, useMutation, useQueryClient} from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useTelegram } from "@/hooks/use-telegram";
import { useUserAvatar } from "@/hooks/use-user-avatar";
import { useToast } from "@/hooks/use-toast";
import { 
  Users, Copy, Share, Star, Bell, Palette, History, Receipt, ShoppingCart, 
  ChevronDown, ChevronUp, Target, Gift
} from "@/components/ui/custom-icons";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import type { SnakeCaseUser, User } from "@shared/schema";

interface ProfileTabProps {
  user?: SnakeCaseUser;
  onTabChange?: (tab: 'buy' | 'earn' | 'sell' | 'profile') => void;
}

interface TransactionHistoryItem {
  id: string;
  description: string;
  amount: number;
  currency: string;
  rub_amount?: number;
  status: string;
  status_text: string;
  status_color: string;
  icon_type: string;
  created_at: string;
  created_at_formatted: string;
}

interface CompletedTaskHistoryItem {
  id: string;
  task_id: string;
  title: string;
  description: string;
  reward: number;
  task_type: string;
  task_type_text: string;
  completed_at: string;
  completed_at_formatted: string;
}

export default function ProfileTab({ user, onTabChange }: ProfileTabProps) {
  const [isPurchaseHistoryExpanded, setIsPurchaseHistoryExpanded] = useState(false);
  const [isTasksHistoryExpanded, setIsTasksHistoryExpanded] = useState(false);

  const { toast } = useToast();
  const { hapticFeedback, shareApp } = useTelegram();
  const userAvatar = useUserAvatar(user?.username);
  const queryClient = useQueryClient();

  const { data: referralStats, refetch: refetchReferrals, isLoading: referralsLoading } = useQuery({
    queryKey: ['/api/referrals/stats'],
    queryFn: async () => {
      console.log('🔍 Fetching referral stats...');
      const response = await apiRequest('GET', '/api/referrals/stats');
      const data = await response.json();
      console.log('🔍 Referral stats response:', data);
      return data;
    },
    staleTime: 0, // Отключаем кэш - данные всегда считаются устаревшими  
    cacheTime: 0, // Данные не хранятся в кэше после unmount
    refetchOnWindowFocus: true, // Обновляем при фокусе окна
    refetchOnMount: true, // Обновляем при монтировании
  });


  const { data: referralConfig } = useQuery({
    queryKey: ['/api/config/referral'],
    queryFn: async () => {
      const response = await apiRequest('GET', '/api/config/referral');
      return response.json();
    },
  });

  // Запрос истории транзакций (только покупки)
  const { data: transactionsData, isLoading: transactionsLoading, error: transactionsError } = useQuery({
    queryKey: ['/api/transactions/history'],
    queryFn: async () => {
      const response = await apiRequest('GET', '/api/transactions/history');
      return response.json();
    },
    refetchOnWindowFocus: false,
    refetchOnMount: true,
  });

  // Запрос выполненных заданий
  const { data: completedTasksData, isLoading: tasksLoading, error: tasksError } = useQuery({
    queryKey: ['/api/tasks/completed'],
    queryFn: async () => {
      const response = await apiRequest('GET', '/api/tasks/completed');
      return response.json();
    },
    refetchOnWindowFocus: false,
    refetchOnMount: true,
  });

  // Mutation для обновления настроек пользователя
  const updateUserMutation = useMutation({
    mutationFn: async (updateData: { notifications_enabled?: boolean }) => {
      const response = await apiRequest('PUT', '/api/users/me', updateData);
      return response.json();
    },
    onSuccess: (updatedUser) => {
      // Обновляем кэш пользователя
      queryClient.setQueryData(['/api/users/me'], updatedUser);
      hapticFeedback('success');
      toast({
        title: "Настройки обновлены",
        description: "Изменения успешно сохранены",
      });
    },
    onError: (error) => {
      console.error('Error updating user:', error);
      hapticFeedback('error');
      toast({
        title: "Ошибка",
        description: "Не удалось обновить настройки",
        variant: "destructive",
      });
    },
  });

  const getUserInitials = () => {
    if (!user) return 'JD';
    const first = user.first_name?.[0] || '';
    const last = user.last_name?.[0] || '';
    return (first + last).toUpperCase() || user.username?.[0]?.toUpperCase() || 'U';
  };

  const copyReferralLink = async () => {
    const referralLink = `${referralConfig?.bot_base_url}?start=${referralConfig?.referral_prefix}${user?.referral_code || '12345678'}`;

    try {
      await navigator.clipboard.writeText(referralLink);
      hapticFeedback('success');
      toast({
        title: "Ссылка скопирована!",
        description: "Реферальная ссылка успешно скопирована в буфер обмена",
      });
    } catch (error) {
      toast({
        title: "Ошибка",
        description: "Не удалось скопировать ссылку",
        variant: "destructive",
      });
    }
  };

  const shareReferralLink = () => {
    hapticFeedback('medium');

    const referralLink = `${referralConfig?.bot_base_url}?start=${referralConfig?.referral_prefix}${user?.referral_code}`;
    const shareText = referralConfig?.default_share_text || 'Попробуй этот крутой обменник Stars и TON!';
    const fullMessage = `${shareText}\n\n${referralLink}`;

    if (window.Telegram?.WebApp) {
      // Используем openTelegramLink вместо switchInlineQuery
      window.Telegram.WebApp.openTelegramLink(
        `https://t.me/share/url?url=${encodeURIComponent(referralLink)}&text=${encodeURIComponent(shareText)}`
      );
    } else {
      // Резерв для браузера
      if (navigator.share) {
        navigator.share({
          title: 'Stars Exchange',
          text: fullMessage,
        }).catch(() => copyReferralLink());
      } else {
        copyReferralLink();
      }
    }
  };

  const handleGoToBuy = () => {
    if (onTabChange) {
      hapticFeedback('light');
      onTabChange('buy');
    }
  };

  const handleGoToTasks = () => {
    if (onTabChange) {
      hapticFeedback('light');
      onTabChange('earn');
    }
  };

  const handleNotificationsToggle = (checked: boolean) => {
    hapticFeedback('light');
    updateUserMutation.mutate({ notifications_enabled: checked });
  };

  const getTransactionIcon = (iconType: string) => {
    switch (iconType) {
      case 'star':
        return <Star className="w-5 h-5 text-yellow-500" />;
      case 'ton':
        return <Receipt className="w-5 h-5 text-[#4E7FFF]" />;
      default:
        return <Receipt className="w-5 h-5 text-gray-500" />;
    }
  };

  const getStatusColor = (statusColor: string) => {
    switch (statusColor) {
      case 'green':
        return 'text-green-500';
      case 'yellow':
        return 'text-yellow-500';
      case 'red':
        return 'text-red-500';
      case 'gray':
        return 'text-gray-500';
      default:
        return 'text-gray-500';
    }
  };

  const renderTransactionItem = (transaction: TransactionHistoryItem) => (
    <div
      key={transaction.id}
      className="flex items-center justify-between p-3 bg-gray-50 dark:bg-[#0E0E10] rounded-lg border border-gray-200 dark:border-white/10"
    >
      <div className="flex items-center space-x-3">
        <div className="w-10 h-10 bg-green-500/20 rounded-lg flex items-center justify-center">
          {getTransactionIcon(transaction.icon_type)}
        </div>
        <div>
          <p className="font-medium">{transaction.description}</p>
          <p className="text-gray-600 dark:text-gray-400 text-sm">
            {transaction.created_at_formatted}
          </p>
        </div>
      </div>
      <div className="text-right">
        <p className={`font-semibold ${getStatusColor(transaction.status_color)}`}>
          {transaction.status_text}
        </p>
        {transaction.rub_amount && (
          <p className="text-gray-600 dark:text-gray-400 text-sm">
            ₽{transaction.rub_amount.toFixed(2)}
          </p>
        )}
      </div>
    </div>
  );

  const renderCompletedTaskItem = (task: CompletedTaskHistoryItem) => (
    <div
      key={task.id}
      className="flex items-center justify-between p-3 bg-gray-50 dark:bg-[#0E0E10] rounded-lg border border-gray-200 dark:border-white/10"
    >
      <div className="flex items-center space-x-3">
        <div className="w-10 h-10 bg-blue-500/20 rounded-lg flex items-center justify-center">
          <Target className="w-5 h-5 text-blue-500" />
        </div>
        <div>
          <p className="font-medium">{task.title}</p>
          <p className="text-gray-600 dark:text-gray-400 text-sm">
            {task.task_type_text} • {task.completed_at_formatted}
          </p>
        </div>
      </div>
      <div className="text-right">
        <p className="font-semibold text-green-500">+{task.reward}</p>
        <p className="text-gray-600 dark:text-gray-400 text-sm flex items-center">
          <Star className="w-3 h-3 mr-1" />
          звезд
        </p>
      </div>
    </div>
  );

  return (
    <div className="space-y-4">
      {/* User Info */}
      <motion.div
        className="bg-white dark:bg-[#1A1A1C] rounded-xl p-4 shadow-lg dark:shadow-[0_4px_20px_rgba(0,0,0,0.3)] border border-gray-200 dark:border-white/10"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
      >
        <div className="flex items-center space-x-4 mb-4">
          {userAvatar?.photo_url ? (
            <img 
              src={userAvatar.photo_url} 
              alt="Avatar" 
              className="w-16 h-16 rounded-full"
            />
          ) : (
            <motion.div
              className="w-16 h-16 bg-gradient-to-br from-[#4E7FFF] to-purple-500 rounded-full flex items-center justify-center"
              whileHover={{ scale: 1.05 }}
            >
              <span className="text-lg font-bold text-white">{getUserInitials()}</span>
            </motion.div>
          )}
          <div>
            <h2 className="text-xl font-bold">
              {user?.first_name} {user?.last_name}
            </h2>
            <p className="text-gray-600 dark:text-gray-400">
              {user?.username ? `@${user.username}` : 'Пользователь'}
            </p>
            <p className="text-gray-600 dark:text-gray-400 text-sm">
              ID: {user?.telegram_id || '12345678'}
            </p>
          </div>
        </div>

        <div className="grid grid-cols-2 gap-4">
          <motion.div
            className="bg-gray-50 dark:bg-[#0E0E10] rounded-lg p-3 text-center"
            whileHover={{ scale: 1.02 }}
          >
            <p className="text-2xl font-bold text-yellow-500 flex items-center justify-center">
              {user?.total_stars_earned || 0} <Star className="w-5 h-5 ml-1" />
            </p>
            <p className="text-gray-600 dark:text-gray-400 text-sm">Всего звезд</p>
          </motion.div>
          <motion.div
            className="bg-gray-50 dark:bg-[#0E0E10] rounded-lg p-3 text-center"
            whileHover={{ scale: 1.02 }}
          >
            <p className="text-2xl font-bold text-[#4E7FFF]">
              {referralStats?.total_referrals || referralStats?.totalReferrals || 0}
            </p>
            <p className="text-gray-600 dark:text-gray-400 text-sm">Рефералов</p>
          </motion.div>
        </div>
      </motion.div>

      {/* Referral System */}
      <motion.div
        className="bg-white dark:bg-[#1A1A1C] rounded-xl p-4 shadow-lg dark:shadow-[0_4px_20px_rgba(0,0,0,0.3)] border border-gray-200 dark:border-white/10"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3, delay: 0.1 }}
      >
        <h3 className="text-lg font-semibold mb-4 flex items-center">
          <Users className="w-5 h-5 text-[#4E7FFF] mr-2" />
          Реферальная программа
        </h3>

        <div className="bg-gradient-to-r from-[#4E7FFF]/20 to-purple-500/20 rounded-lg p-4 mb-4 border border-white/10">
          <p className="font-semibold mb-2">Зарабатывайте {referralConfig?.referral_bonus_percentage || 10}% с каждой покупки!</p>
          <p className="text-gray-600 dark:text-gray-400 text-sm">
            Приглашайте друзей и получайте бонусы за их покупки
          </p>
        </div>

        <div className="space-y-3">
          <div>
            <Label className="text-gray-600 dark:text-gray-400">
              Ваша реферальная ссылка
            </Label>
            <div className="flex mt-2">
              <Input
                value={referralConfig ? `${referralConfig.bot_base_url}?start=${referralConfig.referral_prefix}${user?.referral_code || '12345678'}` : ''}
                readOnly
                className="flex-1 bg-gray-50 dark:bg-[#0E0E10]"
              />
              <Button
                variant="outline"
                size="sm"
                onClick={copyReferralLink}
                className="ml-2"
              >
                <Copy className="w-4 h-4" />
              </Button>
            </div>
          </div>

          <Button
            onClick={shareReferralLink}
            className="w-full bg-[#4E7FFF] hover:bg-[#3D6FFF] text-white"
          >
            <Share className="w-4 h-4 mr-2" />
            Поделиться ссылкой
          </Button>
        </div>
      </motion.div>

      {/* Settings */}
      <motion.div
        className="bg-white dark:bg-[#1A1A1C] rounded-xl p-4 shadow-lg dark:shadow-[0_4px_20px_rgba(0,0,0,0.3)] border border-gray-200 dark:border-white/10"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3, delay: 0.2 }}
      >
        <h3 className="text-lg font-semibold mb-4 flex items-center">
          <Palette className="w-5 h-5 text-purple-500 mr-2" />
          Настройки
        </h3>

        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <Bell className="w-4 h-4 text-gray-500" />
              <Label>Уведомления</Label>
            </div>
            <button
              onClick={() => handleNotificationsToggle(!(user?.notifications_enabled ?? true))}
              disabled={updateUserMutation.isPending}
              className={`
                relative inline-flex h-6 w-11 items-center rounded-full transition-colors
                ${user?.notifications_enabled ?? true ? 'bg-[#4E7FFF]' : 'bg-gray-300 dark:bg-gray-600'}
                ${updateUserMutation.isPending ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}
              `}
            >
              <span
                className={`
                  inline-block h-4 w-4 transform rounded-full bg-white transition-transform
                  ${user?.notifications_enabled ?? true ? 'translate-x-6' : 'translate-x-1'}
                `}
              />
            </button>
          </div>
          
          {/* Индикатор загрузки */}
          {updateUserMutation.isPending && (
            <div className="flex items-center text-sm text-gray-500">
              <div className="animate-spin w-4 h-4 border-2 border-blue-500 border-t-transparent rounded-full mr-2"></div>
              Сохранение...
            </div>
          )}
        </div>
      </motion.div>

      {/* Purchase History */}
      <motion.div
        className="bg-white dark:bg-[#1A1A1C] rounded-xl p-4 shadow-lg dark:shadow-[0_4px_20px_rgba(0,0,0,0.3)] border border-gray-200 dark:border-white/10"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3, delay: 0.3 }}
      >
        <h3 className="text-lg font-semibold mb-4 flex items-center">
          <History className="w-5 h-5 text-purple-500 mr-2" />
          История покупок
        </h3>

        {transactionsLoading ? (
          <div className="flex items-center justify-center py-8">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-[#4E7FFF]"></div>
          </div>
        ) : transactionsError ? (
          <div className="text-center py-8">
            <p className="text-gray-500 dark:text-gray-400 mb-4">
              Ошибка загрузки истории покупок
            </p>
            <Button
              variant="outline"
              onClick={() => window.location.reload()}
              className="mx-auto"
            >
              Обновить
            </Button>
          </div>
        ) : transactionsData?.transactions && transactionsData.transactions.length > 0 ? (
          <div className="space-y-3">
            {/* Первая транзакция - всегда видна */}
            {renderTransactionItem(transactionsData.transactions[0])}
            
            {/* Вторая транзакция - показываем размыто если свернуто */}
            {transactionsData.transactions.length > 1 && !isPurchaseHistoryExpanded && (
              <div className="relative">
                <div className="blur-sm pointer-events-none opacity-60">
                  {renderTransactionItem(transactionsData.transactions[1])}
                </div>
                <div className="absolute inset-0 bg-gradient-to-b from-transparent via-transparent to-white dark:to-[#1A1A1C] pointer-events-none"></div>
              </div>
            )}
            
            {/* Остальные транзакции - показываем только если развернуто */}
            {isPurchaseHistoryExpanded && transactionsData.transactions.slice(1).map((transaction: TransactionHistoryItem) => 
              renderTransactionItem(transaction)
            )}
            
            {/* Кнопка развернуть/свернуть */}
            {transactionsData.transactions.length > 1 && (
              <Button
                variant="ghost"
                onClick={() => {
                  hapticFeedback('light');
                  setIsPurchaseHistoryExpanded(!isPurchaseHistoryExpanded);
                }}
                className="w-full text-[#4E7FFF] hover:bg-[#4E7FFF]/10"
              >
                {isPurchaseHistoryExpanded ? (
                  <>
                    <ChevronUp className="w-4 h-4 mr-2" />
                    Свернуть
                  </>
                ) : (
                  <>
                    <ChevronDown className="w-4 h-4 mr-2" />
                    Показать все ({transactionsData.transactions.length})
                  </>
                )}
              </Button>
            )}
            
            {transactionsData.transactions.length > 10 && (
              <div className="text-center pt-2">
                <p className="text-gray-500 dark:text-gray-400 text-sm">
                  Показаны последние транзакции
                </p>
              </div>
            )}
          </div>
        ) : (
          <div className="text-center py-8">
            <div className="w-16 h-16 bg-gray-100 dark:bg-[#0E0E10] rounded-full flex items-center justify-center mx-auto mb-4">
              <ShoppingCart className="w-8 h-8 text-gray-400" />
            </div>
            <h4 className="text-lg font-semibold mb-2">Покупок пока нет</h4>
            <p className="text-gray-500 dark:text-gray-400 text-sm mb-4">
              Совершите первую покупку Stars или TON
            </p>
            <Button
              onClick={handleGoToBuy}
              className="bg-[#4E7FFF] hover:bg-[#3D6FFF] text-white"
            >
              <ShoppingCart className="w-4 h-4 mr-2" />
              За покупками
            </Button>
          </div>
        )}
      </motion.div>

      {/* Completed Tasks History */}
      <motion.div
        className="bg-white dark:bg-[#1A1A1C] rounded-xl p-4 shadow-lg dark:shadow-[0_4px_20px_rgba(0,0,0,0.3)] border border-gray-200 dark:border-white/10"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3, delay: 0.4 }}
      >
        <h3 className="text-lg font-semibold mb-4 flex items-center">
          <Gift className="w-5 h-5 text-green-500 mr-2" />
          Выполненные задания
        </h3>

        {tasksLoading ? (
          <div className="flex items-center justify-center py-8">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-[#4E7FFF]"></div>
          </div>
        ) : tasksError ? (
          <div className="text-center py-8">
            <p className="text-gray-500 dark:text-gray-400 mb-4">
              Ошибка загрузки выполненных заданий
            </p>
            <Button
              variant="outline"
              onClick={() => window.location.reload()}
              className="mx-auto"
            >
              Обновить
            </Button>
          </div>
        ) : completedTasksData?.completed_tasks && completedTasksData.completed_tasks.length > 0 ? (
          <div className="space-y-3">
            {/* Первое задание - всегда видно */}
            {renderCompletedTaskItem(completedTasksData.completed_tasks[0])}
            
            {/* Второе задание - показываем размыто если свернуто */}
            {completedTasksData.completed_tasks.length > 1 && !isTasksHistoryExpanded && (
              <div className="relative">
                <div className="blur-sm pointer-events-none opacity-60">
                  {renderCompletedTaskItem(completedTasksData.completed_tasks[1])}
                </div>
                <div className="absolute inset-0 bg-gradient-to-b from-transparent via-transparent to-white dark:to-[#1A1A1C] pointer-events-none"></div>
              </div>
            )}
            
            {/* Остальные задания - показываем только если развернуто */}
            {isTasksHistoryExpanded && completedTasksData.completed_tasks.slice(1).map((task: CompletedTaskHistoryItem) => 
              renderCompletedTaskItem(task)
            )}
            
            {/* Кнопка развернуть/свернуть */}
            {completedTasksData.completed_tasks.length > 1 && (
              <Button
                variant="ghost"
                onClick={() => {
                  hapticFeedback('light');
                  setIsTasksHistoryExpanded(!isTasksHistoryExpanded);
                }}
                className="w-full text-green-500 hover:bg-green-500/10"
              >
                {isTasksHistoryExpanded ? (
                  <>
                    <ChevronUp className="w-4 h-4 mr-2" />
                    Свернуть
                  </>
                ) : (
                  <>
                    <ChevronDown className="w-4 h-4 mr-2" />
                    Показать все ({completedTasksData.completed_tasks.length})
                  </>
                )}
              </Button>
            )}
            
            {completedTasksData.completed_tasks.length > 10 && (
              <div className="text-center pt-2">
                <p className="text-gray-500 dark:text-gray-400 text-sm">
                  Показаны последние выполненные задания
                </p>
              </div>
            )}
          </div>
        ) : (
          <div className="text-center py-8">
            <div className="w-16 h-16 bg-gray-100 dark:bg-[#0E0E10] rounded-full flex items-center justify-center mx-auto mb-4">
              <Target className="w-8 h-8 text-gray-400" />
            </div>
            <h4 className="text-lg font-semibold mb-2">Заданий пока не выполнено</h4>
            <p className="text-gray-500 dark:text-gray-400 text-sm mb-4">
              Выполните первое задание и получите звезды
            </p>
            <Button
              onClick={handleGoToTasks}
              className="bg-green-500 hover:bg-green-600 text-white"
            >
              <Target className="w-4 h-4 mr-2" />
              К заданиям
            </Button>
          </div>
        )}
      </motion.div>
    </div>
  );
}

================================================================================
FILE: frontend\src\components\task-admin-page.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Switch } from '@/components/ui/switch';
import { Plus, Edit, Trash2, Eye } from 'lucide-react';

const TaskAdminPage = () => {
  const [token, setToken] = useState('');
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [tasks, setTasks] = useState([]);
  const [showForm, setShowForm] = useState(false);
  const [editingTask, setEditingTask] = useState(null);
  
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    reward: 10,
    type: 'daily',
    action: '',
    status: 'active',
    deadline: '',
    maxCompletions: '',
    requirements: '',
    url: '',  // ✅ ДОБАВЛЕНО
    isActive: true
  });

  // Проверка токена из URL
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const urlToken = urlParams.get('token') || window.location.pathname.split('/admin')[1];
    if (urlToken) {
      setToken(urlToken);
      checkAuth(urlToken);
    }
  }, []);

  const checkAuth = async (authToken) => {
    try {
      const response = await fetch(`/api/admin/tasks/list?token=${authToken}`);
      if (response.ok) {
        setIsAuthenticated(true);
        loadTasks(authToken);
      }
    } catch (error) {
      console.error('Auth failed:', error);
    }
  };

  const loadTasks = async (authToken) => {
    try {
      const response = await fetch(`/api/admin/tasks/list?token=${authToken}`);
      const data = await response.json();
      setTasks(data);
    } catch (error) {
      console.error('Failed to load tasks:', error);
    }
  };

  // ✅ ИСПРАВЛЕННЫЙ handleSubmit:
  const handleSubmit = async () => {
    try {
      const url = editingTask 
        ? `/api/admin/tasks/${editingTask.id}` 
        : '/api/admin/tasks/create';
      
      const method = editingTask ? 'PUT' : 'POST';
      
      // ✅ ОЧИЩАЕМ ДАННЫЕ ПЕРЕД ОТПРАВКОЙ
      const cleanFormData = {
        title: formData.title,
        description: formData.description,
        reward: formData.reward,
        type: formData.type,
        status: formData.status,
        isActive: formData.isActive
      };
      
      // Добавляем опциональные поля только если они не пустые
      if (formData.action && formData.action.trim() !== '') {
        cleanFormData.action = formData.action;
      }
      
      if (formData.deadline && formData.deadline.trim() !== '') {
        cleanFormData.deadline = formData.deadline;
      }
      
      if (formData.maxCompletions && formData.maxCompletions.trim() !== '') {
        cleanFormData.maxCompletions = formData.maxCompletions;
      }
      
      if (formData.requirements && formData.requirements.trim() !== '') {
        cleanFormData.requirements = formData.requirements;
      }
      
      if (formData.url && formData.url.trim() !== '') {
        cleanFormData.url = formData.url;  // ✅ ДОБАВЛЕНО
      }
      
      const response = await fetch(`${url}?token=${token}`, {
        method,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(cleanFormData)  // ✅ Отправляем очищенные данные
      });

      if (response.ok) {
        resetForm();
        loadTasks(token);
        alert(editingTask ? 'Задание обновлено!' : 'Задание создано!');
      } else {
        const error = await response.text();
        alert('Ошибка: ' + error);
      }
    } catch (error) {
      alert('Ошибка: ' + error.message);
    }
  };

  const resetForm = () => {
    setFormData({
      title: '', description: '', reward: 10, type: 'daily', action: '',
      status: 'active', deadline: '', maxCompletions: '', requirements: '', 
      url: '',  // ✅ ДОБАВЛЕНО
      isActive: true
    });
    setShowForm(false);
    setEditingTask(null);
  };

  const editTask = (task) => {
    setFormData(task);
    setEditingTask(task);
    setShowForm(true);
  };

  const deleteTask = async (taskId) => {
    if (confirm('Архивировать задание?')) {
      try {
        await fetch(`/api/admin/tasks/${taskId}?token=${token}`, { method: 'DELETE' });
        loadTasks(token);
        alert('Задание архивировано!');
      } catch (error) {
        alert('Ошибка удаления');
      }
    }
  };

  if (!isAuthenticated) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <Card className="w-96">
          <CardHeader>
            <CardTitle>Доступ запрещен</CardTitle>
            <CardDescription>Неверный токен доступа</CardDescription>
          </CardHeader>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 p-4">
      <div className="max-w-6xl mx-auto">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-3xl font-bold">Админка заданий</h1>
          <Button onClick={() => setShowForm(true)}>
            <Plus className="w-4 h-4 mr-2" />
            Новое задание
          </Button>
        </div>

        {/* Форма создания/редактирования */}
        {showForm && (
          <Card className="mb-6">
            <CardHeader>
              <CardTitle>{editingTask ? 'Редактировать задание' : 'Новое задание'}</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <Label>Название</Label>
                    <Input 
                      value={formData.title}
                      onChange={(e) => setFormData({...formData, title: e.target.value})}
                      required
                    />
                  </div>
                  <div>
                    <Label>Награда (звезды)</Label>
                    <Input 
                      type="number"
                      value={formData.reward}
                      onChange={(e) => setFormData({...formData, reward: parseInt(e.target.value)})}
                      required
                    />
                  </div>
                </div>

                <div>
                  <Label>Описание</Label>
                  <Textarea 
                    value={formData.description}
                    onChange={(e) => setFormData({...formData, description: e.target.value})}
                    maxLength={200}
                    required
                  />
                </div>

                <div className="grid grid-cols-3 gap-4">
                  <div>
                    <Label>Тип</Label>
                    <Select value={formData.type} onValueChange={(value) => setFormData({...formData, type: value})}>
                      <SelectTrigger>
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="daily">Ежедневное</SelectItem>
                        <SelectItem value="social">Социальное</SelectItem>
                        <SelectItem value="referral">Реферальное</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>

                  <div>
                    <Label>Действие</Label>
                    <Select value={formData.action} onValueChange={(value) => setFormData({...formData, action: value})}>
                      <SelectTrigger>
                        <SelectValue placeholder="Выберите действие" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="daily_login">Ежедневный вход</SelectItem>
                        <SelectItem value="share_app">Поделиться приложением</SelectItem>
                        <SelectItem value="follow_channel">Подписаться на канал</SelectItem>
                        <SelectItem value="invite_friends">Пригласить друзей</SelectItem>
                        <SelectItem value="complete_purchase">Совершить покупку</SelectItem>
                        <SelectItem value="visit_website">Посетить сайт</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>

                  <div>
                    <Label>Статус</Label>
                    <Select value={formData.status} onValueChange={(value) => setFormData({...formData, status: value})}>
                      <SelectTrigger>
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="draft">Черновик</SelectItem>
                        <SelectItem value="active">Активное</SelectItem>
                        <SelectItem value="paused">Приостановлено</SelectItem>
                        <SelectItem value="expired">Истекло</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <Label>Дедлайн (опционально)</Label>
                    <Input 
                      type="datetime-local"
                      value={formData.deadline}
                      onChange={(e) => setFormData({...formData, deadline: e.target.value})}
                    />
                  </div>
                  <div>
                    <Label>Макс. выполнений (опционально)</Label>
                    <Input 
                      type="number"
                      value={formData.maxCompletions}
                      onChange={(e) => setFormData({...formData, maxCompletions: e.target.value})}
                    />
                  </div>
                </div>

                <div>
                  <Label>Требования (JSON, опционально)</Label>
                  <Textarea 
                    value={formData.requirements}
                    onChange={(e) => setFormData({...formData, requirements: e.target.value})}
                    placeholder='{"minLevel": 1, "completedTasks": []}'
                  />
                </div>

                {/* ✅ ДОБАВЛЕНО ПОЛЕ URL: */}
                <div>
                  <Label>URL (для переходов)</Label>
                  <Input 
                    type="url"
                    value={formData.url || ''}
                    onChange={(e) => setFormData({...formData, url: e.target.value})}
                    placeholder="https://t.me/channel или любая ссылка"
                  />
                </div>

                <div className="flex items-center space-x-2">
                  <Switch 
                    checked={formData.isActive}
                    onCheckedChange={(checked) => setFormData({...formData, isActive: checked})}
                  />
                  <Label>Активное</Label>
                </div>

                <div className="flex gap-2">
                  <Button onClick={handleSubmit}>{editingTask ? 'Обновить' : 'Создать'}</Button>
                  <Button variant="outline" onClick={resetForm}>Отмена</Button>
                </div>
              </div>
            </CardContent>
          </Card>
        )}

        {/* Список заданий */}
        <Card>
          <CardHeader>
            <CardTitle>Список заданий ({tasks.length})</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="overflow-x-auto">
              <table className="w-full border-collapse">
                <thead>
                  <tr className="border-b">
                    <th className="text-left p-2">Название</th>
                    <th className="text-left p-2">Тип</th>
                    <th className="text-left p-2">Награда</th>
                    <th className="text-left p-2">Статус</th>
                    <th className="text-left p-2">Выполнено</th>
                    <th className="text-left p-2">Действия</th>
                  </tr>
                </thead>
                <tbody>
                  {tasks.map(task => (
                    <tr key={task.id} className="border-b hover:bg-gray-50">
                      <td className="p-2 font-medium">{task.title}</td>
                      <td className="p-2">{task.type}</td>
                      <td className="p-2">{task.reward} ⭐</td>
                      <td className="p-2">
                        <span className={`px-2 py-1 rounded text-xs ${
                          task.status === 'active' ? 'bg-green-100 text-green-800' :
                          task.status === 'draft' ? 'bg-gray-100 text-gray-800' :
                          task.status === 'paused' ? 'bg-yellow-100 text-yellow-800' :
                          'bg-red-100 text-red-800'
                        }`}>
                          {task.status}
                        </span>
                      </td>
                      <td className="p-2">{task.completedCount || 0}</td>
                      <td className="p-2">
                        <div className="flex gap-1">
                          <Button size="sm" variant="outline" onClick={() => editTask(task)}>
                            <Edit className="w-3 h-3" />
                          </Button>
                          <Button size="sm" variant="outline" onClick={() => deleteTask(task.id)}>
                            <Trash2 className="w-3 h-3" />
                          </Button>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default TaskAdminPage;

================================================================================
FILE: frontend\src\components\tasks-tab.tsx
================================================================================

import { useState } from "react";
import { motion } from "framer-motion";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useTelegram } from "@/hooks/use-telegram";
import { CalendarDays, ThumbsUp, CheckCircle, Share, Users, Star, ShoppingCart, ExternalLink } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import type { SnakeCaseUser, User } from "@shared/schema";

interface TasksTabProps {
  user?: SnakeCaseUser;
}

interface TaskWithCompletion {
  id: string;
  title: string;
  description: string;
  reward: number;
  type: string;
  action?: string;
  completed: boolean;
  completedAt?: string | null;
  completion_title?: string;
  completion_text?: string;
  share_text?: string;
  button_text?: string;
}

export default function TasksTab({ user }: TasksTabProps) {
  const { toast } = useToast();
  const { hapticFeedback, shareApp } = useTelegram();
  const queryClient = useQueryClient();
  const [openedTasks, setOpenedTasks] = useState(new Set());

  // ✅ ПРАВИЛЬНО - useQuery ВНУТРИ КОМПОНЕНТА!
  const { data: interfaceTexts } = useQuery({
    queryKey: ['/api/config/interface-texts'],
    queryFn: async () => {
      const response = await apiRequest('GET', '/api/config/interface-texts');
      return response.json();
    },
  });

  const { data: tasks = [], isLoading } = useQuery({
    queryKey: ['/api/tasks'],
    queryFn: async () => {
      const response = await apiRequest('GET', '/api/tasks');
      return response.json() as Promise<TaskWithCompletion[]>;
    },
  });

  const completeTaskMutation = useMutation({
    mutationFn: async (taskId: string) => {
      const response = await apiRequest('POST', `/api/tasks/${taskId}/complete`);
      return response.json();
    },
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ['/api/tasks'] });
      queryClient.invalidateQueries({ queryKey: ['/api/users/me'] });
      hapticFeedback('success');
      const task = tasks.find(t => t.id === data.taskId);
      toast({
        title: task?.completion_title || "Задание выполнено!",
        description: task?.completion_text?.replace('{reward}', data.reward.toString()) || `Вы получили ${data.reward} звезд`,
      });
    },
    onError: () => {
      toast({
        title: interfaceTexts?.error || "Ошибка",
        description: "Задание не выполнено, попробуйте еще раз",
        variant: "destructive",
      });
    },
  });

  const checkTaskCompletion = async (taskId) => {
    const isCompleted = await verifyTaskCompletion(taskId);
    if (isCompleted) {
      completeTaskMutation.mutate(taskId);
      setOpenedTasks(prev => {
        const newSet = new Set(prev);
        newSet.delete(taskId);
        return newSet;
      });
    } else {
      toast({
        title: interfaceTexts?.error || "Ошибка",
        description: "Задание не выполнено, попробуйте еще раз",
        variant: "destructive",
      });
    }
  };

  const verifyTaskCompletion = async (taskId) => {
    console.log(`Проверяем выполнение задания: ${taskId}`);
    return Math.random() > 0.3;
  };

  const handleTaskAction = async (task: TaskWithCompletion) => {
    if (task.completed) return;

    hapticFeedback('light');

    let taskUrl = null;
    try {
      const req = JSON.parse(task.requirements || '{}');
      taskUrl = req.url;
    } catch {}

    switch (task.action) {
      case 'follow_channel':
      case 'visit_website':
        if (taskUrl) {
          if (window.Telegram?.WebApp?.openTelegramLink && taskUrl.includes('t.me')) {
            window.Telegram.WebApp.openTelegramLink(taskUrl);
          } else if (window.Telegram?.WebApp?.openLink) {
            window.Telegram.WebApp.openLink(taskUrl);
          } else {
            window.open(taskUrl, '_blank');
          }
          
          setOpenedTasks(prev => new Set([...prev, task.id]));
          return;
        }
        break;
        
      case 'share_app':
        shareApp(task.share_text || 'Попробуй этот крутой обменник Stars и TON!');
        break;
      case 'invite_friends':
        shareApp(`Попробуй Stars Exchange! ${window.location.origin}?ref=${user?.referralCode}`);
        break;
      case 'complete_purchase':
        if (typeof window !== 'undefined') {
          const event = new CustomEvent('switchTab', { detail: 'buy' });
          window.dispatchEvent(event);
        }
        break;
      case 'daily_login':
        break;
    }

    completeTaskMutation.mutate(task.id);
  };

  const getTaskIcon = (type: string, action?: string) => {
    if (action === 'share_app') return Share;
    if (action === 'follow_channel') return Users;
    if (action === 'invite_friends') return Users;
    if (action === 'complete_purchase') return ShoppingCart;
    if (action === 'visit_website') return ExternalLink;
    if (type === 'daily') return CalendarDays;
    if (type === 'social') return ThumbsUp;
    return CheckCircle;
  };

  const getTaskIconColor = (type: string, action?: string) => {
    if (action === 'share_app') return 'text-[#4E7FFF]';
    if (action === 'follow_channel') return 'text-blue-400';
    if (action === 'invite_friends') return 'text-green-500';
    if (action === 'complete_purchase') return 'text-purple-500';
    if (action === 'visit_website') return 'text-orange-500';
    if (type === 'daily') return 'text-yellow-500';
    if (type === 'social') return 'text-[#4E7FFF]';
    return 'text-green-500';
  };

  const dailyTasks = tasks.filter(task => task.type === 'daily');
  const socialTasks = tasks.filter(task => task.type === 'social' || task.type === 'referral');
  const completedTasks = tasks.filter(task => task.completed).length;
  const totalTasks = tasks.length;
  const progressPercentage = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-gray-500">Загрузка заданий...</div>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Progress Section */}
      <motion.div
        className="bg-white dark:bg-[#1A1A1C] rounded-xl p-6 shadow-lg dark:shadow-[0_4px_20px_rgba(0,0,0,0.3)] border border-gray-200 dark:border-white/10"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.3 }}
      >
        <h3 className="text-lg font-semibold mb-4">Прогресс выполнения</h3>
        <Progress value={progressPercentage} className="mb-2" />
        <p className="text-gray-600 dark:text-gray-400 text-sm">
          Выполнено {completedTasks} из {totalTasks} заданий
        </p>
      </motion.div>

      {/* Daily Tasks */}
      {dailyTasks.length > 0 && (
        <motion.div
          className="bg-white dark:bg-[#1A1A1C] rounded-xl p-6 shadow-lg dark:shadow-[0_4px_20px_rgba(0,0,0,0.3)] border border-gray-200 dark:border-white/10"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.3, delay: 0.1 }}
        >
          <h3 className="text-lg font-semibold mb-4">Ежедневные задания</h3>
          <div className="space-y-3">
            {dailyTasks.map((task) => {
              const Icon = getTaskIcon(task.type, task.action);
              const iconColor = getTaskIconColor(task.type, task.action);
              
              return (
                <motion.div
                  key={task.id}
                  className="flex items-center justify-between p-4 bg-gray-50 dark:bg-[#0E0E10] rounded-lg hover:bg-gray-100 dark:hover:bg-white/5 transition-colors"
                  whileHover={{ scale: 1.02 }}
                  whileTap={{ scale: 0.98 }}
                >
                  <div className="flex items-center space-x-4">
                    <div className={`w-10 h-10 ${task.completed ? 'bg-green-500/20' : 'bg-gray-200 dark:bg-gray-700/20'} rounded-lg flex items-center justify-center`}>
                      {task.completed ? (
                        <CheckCircle className="w-5 h-5 text-green-500" />
                      ) : (
                        <Icon className={`w-5 h-5 ${iconColor}`} />
                      )}
                    </div>
                    <div>
                      <p className="font-medium">{task.title}</p>
                      <p className="text-gray-600 dark:text-gray-400 text-sm">{task.description}</p>
                    </div>
                  </div>
                  <div className="text-right">
                    <p className="font-semibold text-yellow-500 flex items-center">
                      +{task.reward} <Star className="w-4 h-4 ml-1" />
                    </p>
                    {task.completed ? (
                      <p className="text-green-500 text-xs">Выполнено</p>
                    ) : (
                      <Button
                        onClick={() => handleTaskAction(task)}
                        disabled={completeTaskMutation.isPending}
                        variant="link"
                        className="text-[#4E7FFF] hover:underline p-0 h-auto text-xs"
                      >
                        {completeTaskMutation.isPending ? 'Загрузка...' : task.button_text || 'Выполнить'}
                      </Button>
                    )}
                  </div>
                </motion.div>
              );
            })}
          </div>
        </motion.div>
      )}

      {/* Social Tasks */}
      {socialTasks.length > 0 && (
        <motion.div
          className="bg-white dark:bg-[#1A1A1C] rounded-xl p-6 shadow-lg dark:shadow-[0_4px_20px_rgba(0,0,0,0.3)] border border-gray-200 dark:border-white/10"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.3, delay: 0.2 }}
        >
          <h3 className="text-lg font-semibold mb-4">Социальные задания</h3>
          <div className="space-y-3">
            {socialTasks.map((task) => {
              const Icon = getTaskIcon(task.type, task.action);
              const iconColor = getTaskIconColor(task.type, task.action);
              
              return (
                <motion.div
                  key={task.id}
                  className="flex items-center justify-between p-4 bg-gray-50 dark:bg-[#0E0E10] rounded-lg hover:bg-gray-100 dark:hover:bg-white/5 transition-colors"
                  whileHover={{ scale: 1.02 }}
                  whileTap={{ scale: 0.98 }}
                >
                  <div className="flex items-center space-x-4">
                    <div className={`w-10 h-10 ${task.completed ? 'bg-green-500/20' : 'bg-gray-200 dark:bg-gray-700/20'} rounded-lg flex items-center justify-center`}>
                      {task.completed ? (
                        <CheckCircle className="w-5 h-5 text-green-500" />
                      ) : (
                        <Icon className={`w-5 h-5 ${iconColor}`} />
                      )}
                    </div>
                    <div>
                      <p className="font-medium">{task.title}</p>
                      <p className="text-gray-600 dark:text-gray-400 text-sm">{task.description}</p>
                    </div>
                  </div>
                  <div className="text-right">
                    <p className="font-semibold text-yellow-500 flex items-center">
                      +{task.reward} <Star className="w-4 h-4 ml-1" />
                    </p>
                    {task.completed ? (
                      <p className="text-green-500 text-xs">Выполнено</p>
                    ) : openedTasks.has(task.id) ? (
                      <Button
                        onClick={() => checkTaskCompletion(task.id)}
                        disabled={completeTaskMutation.isPending}
                        variant="outline"
                        className="text-green-600 border-green-600 hover:bg-green-50 text-xs h-auto p-1"
                      >
                        Проверить
                      </Button>
                    ) : (
                      <Button
                        onClick={() => handleTaskAction(task)}
                        disabled={completeTaskMutation.isPending}
                        variant="link"
                        className="text-[#4E7FFF] hover:underline p-0 h-auto text-xs"
                      >
                        {completeTaskMutation.isPending ? 'Загрузка...' : task.button_text || 'Выполнить'}
                      </Button>
                    )}
                  </div>
                </motion.div>
              );
            })}
          </div>
        </motion.div>
      )}
    </div>
  );
}

================================================================================
FILE: frontend\src\components\telegram-app.tsx
================================================================================

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useTelegram } from "@/hooks/use-telegram";
import { useTheme } from "@/hooks/use-theme";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useUserAvatar } from "@/hooks/use-user-avatar";
import BalanceCard from "./balance-card";
import BuyTab from "./buy-tab";
import TasksTab from "./tasks-tab";
import ProfileTab from "./profile-tab";
import LoadingModal from "./loading-modal";
import TelegramGuard from "./telegram-guard";
import { Star, Moon, Sun, User, ShoppingCart, CheckSquare, Coins, TrendingUp } from "@/components/ui/custom-icons";
import type { SnakeCaseUser, User as UserType } from "../../shared/schema";

type TabType = 'buy' | 'earn' | 'sell' | 'profile';

export default function TelegramApp() {
  const [currentTab, setCurrentTab] = useState<TabType>('buy');
  const [isLoading, setIsLoading] = useState(false);
  const [loadingMessage, setLoadingMessage] = useState('');

  const { user, isAvailable, hapticFeedback } = useTelegram();
  const { theme, toggleTheme, isDark } = useTheme();
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Initialize user
  const createUserMutation = useMutation({
    mutationFn: async (userData: any) => {
      const response = await apiRequest('POST', '/api/users', userData);
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/users/me'] });
    },
  });

  // Get current user data
  const { data: currentUser, isLoading: userLoading } = useQuery<SnakeCaseUser>({
    queryKey: ['/api/users/me'],
    queryFn: async () => {
      const response = await apiRequest('GET', '/api/users/me');
      return response.json();
    },
    enabled: !!user,
  });
  const userAvatar = useUserAvatar(currentUser?.username);

  useEffect(() => {
    if (user && !currentUser && !userLoading) {
      createUserMutation.mutate({
        telegram_id: user.id.toString(),
        username: user.username || null,
        first_name: user.first_name,
        last_name: user.last_name || null,
      });
    }
  }, [user, currentUser, userLoading]);

  const handleTabChange = (tab: TabType) => {
    hapticFeedback('light');
    setCurrentTab(tab);
  };


  const showLoadingModal = (message: string) => {
    setLoadingMessage(message);
    setIsLoading(true);
  };

  const hideLoadingModal = () => {
    setIsLoading(false);
    setLoadingMessage('');
  };

  const getUserInitials = () => {
    if (!user) return 'JD';
    const first = user.first_name?.[0] || '';
    const last = user.last_name?.[0] || '';
    return (first + last).toUpperCase() || user.username?.[0]?.toUpperCase() || 'U';
  };

  if (userLoading) {
    return (
      <div className="min-h-screen bg-dark-bg dark:bg-dark-bg flex items-center justify-center">
        <div className="animate-spin w-12 h-12 border-4 border-accent-blue border-t-transparent rounded-full"></div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-white dark:bg-[#0E0E10] text-gray-900 dark:text-white transition-colors duration-200">
      {/* Header */}
      <header className="sticky top-0 z-50 bg-white/80 dark:bg-[#0E0E10]/80 backdrop-blur-lg border-b border-gray-200 dark:border-white/10">
        <div className="flex items-center justify-between p-4">
          <div className="flex items-center space-x-3">
            <motion.div
              className="w-8 h-8 bg-[#4E7FFF] rounded-lg flex items-center justify-center"
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
            >
              <Star className="w-4 h-4 text-white" />
            </motion.div>
            <h1 className="text-lg font-bold">Stars Exchange</h1>
          </div>
          <div className="flex items-center space-x-3">
            <motion.button
              onClick={toggleTheme}
              className="p-2 rounded-lg bg-gray-100 dark:bg-[#1A1A1C] hover:bg-gray-200 dark:hover:bg-white/10 transition-colors"
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
            >
              {isDark ? <Sun className="w-4 h-4" /> : <Moon className="w-4 h-4" />}
            </motion.button>
            {userAvatar?.photo_url ? (
              <img 
                src={userAvatar.photo_url} 
                alt="Avatar" 
                className="w-8 h-8 rounded-full"
              />
            ) : (
              <motion.div
                className="w-8 h-8 bg-gradient-to-br from-[#4E7FFF] to-purple-500 rounded-full flex items-center justify-center cursor-pointer"
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
              >
                <span className="text-xs font-bold text-white">{getUserInitials()}</span>
              </motion.div>
            )}
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main className="pb-20">
        <BalanceCard user={currentUser} />


        {/* Tab Content */}
        <AnimatePresence mode="wait">
          <motion.div
            key={currentTab}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ duration: 0.2, ease: "easeOut" }}
            className="px-4"
          >
            {currentTab === 'buy' && (
              <BuyTab
                user={currentUser}
                onShowLoading={showLoadingModal}
                onHideLoading={hideLoadingModal}
              />
            )}
            {currentTab === 'earn' && <TasksTab user={currentUser} />}
            {currentTab === 'sell' && (
              <div className="bg-white dark:bg-[#1A1A1C] rounded-xl p-6 shadow-lg text-center">
                <TrendingUp className="w-12 h-12 text-[#4E7FFF] mx-auto mb-4" />
                <h3 className="text-xl font-bold mb-2">Продажа</h3>
                <p className="text-gray-600 dark:text-gray-400 mb-4">
                  Функция продажи криптовалюты находится в разработке
                </p>
                <div className="text-sm text-gray-500 dark:text-gray-500">
                  Скоро будет доступна возможность продать ваши TON и Stars
                </div>
              </div>
            )}
            {currentTab === 'profile' && <ProfileTab user={currentUser} onTabChange={handleTabChange} />}
          </motion.div>
        </AnimatePresence>
      </main>

      {/* Bottom Navigation */}
      <nav className="fixed bottom-0 left-0 right-0 bg-white/80 dark:bg-[#1A1A1C]/80 backdrop-blur-lg border-t border-gray-200 dark:border-white/10">
        <div className="flex items-center justify-around py-2">
          {[
            { id: 'buy', icon: ShoppingCart, label: 'Купить' },
            { id: 'earn', icon: Coins, label: 'Заработать' },
            { id: 'sell', icon: TrendingUp, label: 'Продать' },
            { id: 'profile', icon: User, label: 'Профиль' },
          ].map((tab) => (
            <motion.button
              key={tab.id}
              onClick={() => handleTabChange(tab.id as TabType)}
              className={`flex flex-col items-center py-2 px-4 transition-colors ${currentTab === tab.id
                ? 'text-[#4E7FFF]'
                : 'text-gray-500 dark:text-gray-400'
                }`}
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
            >
              <tab.icon className="w-5 h-5 mb-1" />
              <span className="text-xs">{tab.label}</span>
            </motion.button>
          ))}
        </div>
      </nav>


      {/* Loading Modal */}
      <LoadingModal
        isOpen={isLoading}
        message={loadingMessage}
      />
    </div>
  );
}


================================================================================
FILE: frontend\src\components\telegram-guard.tsx
================================================================================


import { useTelegram } from "@/hooks/use-telegram";
import { motion } from "framer-motion";
import { MessageCircle, Smartphone, Monitor } from "lucide-react";

interface TelegramGuardProps {
  children: React.ReactNode;
}

export default function TelegramGuard({ children }: TelegramGuardProps) {
  const { isAvailable, user } = useTelegram();

  if (!isAvailable || !user) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-gray-900 dark:to-gray-800 flex items-center justify-center p-4">
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="max-w-md w-full bg-white dark:bg-gray-800 rounded-2xl shadow-xl p-8 text-center"
        >
          <div className="flex justify-center mb-6">
            <div className="relative">
              <div className="w-20 h-20 bg-blue-100 dark:bg-blue-900 rounded-full flex items-center justify-center">
                <MessageCircle className="w-10 h-10 text-blue-600 dark:text-blue-400" />
              </div>
              <div className="absolute -top-2 -right-2 w-8 h-8 bg-red-100 dark:bg-red-900 rounded-full flex items-center justify-center">
                <span className="text-red-600 dark:text-red-400 text-xl">!</span>
              </div>
            </div>
          </div>
          
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white mb-4">
            Доступ только через Telegram
          </h1>
          
          <p className="text-gray-600 dark:text-gray-300 mb-6 leading-relaxed">
            Это приложение работает только внутри Telegram. 
            Пожалуйста, откройте его через Telegram бота.
          </p>
          
          <div className="space-y-4">
            <div className="flex items-center justify-center space-x-4 text-sm text-gray-500 dark:text-gray-400">
              <div className="flex items-center space-x-2">
                <Smartphone className="w-4 h-4" />
                <span>Мобильный</span>
              </div>
              <div className="w-1 h-1 bg-gray-400 rounded-full"></div>
              <div className="flex items-center space-x-2">
                <Monitor className="w-4 h-4" />
                <span>Десктоп</span>
              </div>
            </div>
          </div>
        </motion.div>
      </div>
    );
  }

  return <>{children}</>;
}


================================================================================
FILE: frontend\src\components\ui\accordion.tsx
================================================================================

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }


================================================================================
FILE: frontend\src\components\ui\alert-dialog.tsx
================================================================================

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}


================================================================================
FILE: frontend\src\components\ui\alert.tsx
================================================================================

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }


================================================================================
FILE: frontend\src\components\ui\aspect-ratio.tsx
================================================================================

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }


================================================================================
FILE: frontend\src\components\ui\avatar.tsx
================================================================================

"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }


================================================================================
FILE: frontend\src\components\ui\badge.tsx
================================================================================

import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }


================================================================================
FILE: frontend\src\components\ui\breadcrumb.tsx
================================================================================

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}


================================================================================
FILE: frontend\src\components\ui\button-withdrawal.tsx
================================================================================

import React from "react";

interface ButtonWithdrawalProps {
  onClick: () => void;
  disabled?: boolean;
}

const ButtonWithdrawal: React.FC<ButtonWithdrawalProps> = ({ onClick, disabled = false }) => {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`
        bg-gradient-to-r from-[#6B48FF] to-[#A64DFF] text-white font-semibold rounded-lg flex items-center justify-center px-4 py-2
        ${disabled ? 'opacity-50 cursor-not-allowed' : 'hover:opacity-90 active:opacity-80'}
        transition-opacity duration-200
      `}
    >
      <svg
        className="w-4 h-4 mr-2"
        fill="none"
        stroke="currentColor"
        viewBox="0 0 24 24"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7" />
      </svg>
      Вывести
    </button>
  );
};

export default ButtonWithdrawal;

================================================================================
FILE: frontend\src\components\ui\button.tsx
================================================================================

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }


================================================================================
FILE: frontend\src\components\ui\calendar.tsx
================================================================================

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }


================================================================================
FILE: frontend\src\components\ui\card.tsx
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


================================================================================
FILE: frontend\src\components\ui\carousel.tsx
================================================================================

import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}


================================================================================
FILE: frontend\src\components\ui\chart.tsx
================================================================================

"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item?.dataKey || item?.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}


================================================================================
FILE: frontend\src\components\ui\checkbox.tsx
================================================================================

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }


================================================================================
FILE: frontend\src\components\ui\collapsible.tsx
================================================================================

"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }


================================================================================
FILE: frontend\src\components\ui\command.tsx
================================================================================

import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}


================================================================================
FILE: frontend\src\components\ui\context-menu.tsx
================================================================================

import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}


================================================================================
FILE: frontend\src\components\ui\custom-icons.tsx
================================================================================

// frontend/src/components/ui/custom-icons.tsx

import React, { useState } from 'react';
import { 
  Star as LucideStar, 
  Bitcoin as LucideBitcoin,
  Coins as LucideCoins,
  Shield as LucideShield,
  BarChart3 as LucideBarChart3,
  Share as LucideShare,
  // Импортируем все остальные иконки из lucide-react
  ShoppingCart,
  Calculator,
  ExternalLink,
  CalendarDays,
  ThumbsUp,
  CheckCircle,
  Users,
  Copy,
  Tag,
  History,
  Moon,
  Sun,
  User,
  TrendingUp,
  ChevronRight,
  MoreHorizontal,
  DollarSign,
  Activity,
  ArrowLeft,
  Bell, 
  Palette, 
  Receipt, 
  ChevronDown, 
  ChevronUp, 
  Target, 
  Gift,
} from "lucide-react";

// Конфигурация кастомных иконок с более надежными источниками
const ICON_URLS = {
  star: "https://pikaso.cdnpk.net/private/production/2265326327/upload.png?token=exp=1774483200~hmac=13f1b9086da73cf1a35a5cd50fb0e06d4c32cc1e8a746780c4c6fcfc054e9eb7",
  bitcoin: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTAiIGZpbGw9IiNGNzk0MUEiLz4KPHA+dGggZD0iTTEzLjUgNy41VjZIMTJWNy41SDEwLjVWOUgxMlY2SDEzLjVaTTEwLjUgOS4ySDEyVjEySDEzLjVWMTRIMTJWMTVIMTAuNVYxNEg5VjEySDEwLjVWOS4yWiIgZmlsbD0iI0ZGRkZGRiIvPgo8L3N2Zz4K",
  ton: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTAiIGZpbGw9IiMwMDg4Q0MiLz4KPHRleHQgeD0iMTIiIHk9IjE2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSJ3aGl0ZSIgZm9udC1zaXplPSIxMiIgZm9udC13ZWlnaHQ9ImJvbGQiPlQ8L3RleHQ+Cjwvc3ZnPgo=",
  telegram: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTIiIGN5PSIxMiIgcj0iMTAiIGZpbGw9IiMyQUFCRUUiLz4KPHBhdGggZD0iTTEwIDEzLjVMOS41IDE3TDggMTZMMTYgOEw5IDEzSDEwVjEzLjVaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K",
  shield: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEyIDJMMTMuMDkgOC4yNkwyMiA5TDE3IDEzLjc0TDE4LjE4IDIxTDEyIDE3Ljc3TDUuODIgMjFMNyAxMy43NEwyIDlMOC45MSA4LjI2TDEyIDJaIiBmaWxsPSIjNEY0NkU1Ii8+Cjwvc3ZnPgo=",
  chart: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTMgM1YyMUgyMVYxOUg1VjNIM1oiIHN0cm9rZT0iIzRGNDZFNSIgc3Ryb2tlLXdpZHRoPSIyIi8+CjxwYXRoIGQ9Ik05IDlWMTVIMTFWOUg5WiIgZmlsbD0iIzRGNDZFNSIvPgo8cGF0aCBkPSJNMTMgNVYxNUgxNVY1SDEzWiIgZmlsbD0iIzRGNDZFNSIvPgo8cGF0aCBkPSJNMTcgMTNWMTVIMTlWMTNIMTdaIiBmaWxsPSIjNEY0NkU1Ii8+Cjwvc3ZnPgo=",
  wallet: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTIwIDdIMTdWNkMxNyA0LjkgMTYuMSA0IDE1IDRINUMzLjkgNCAzIDQuOSAzIDZWMThDMyAxOS4xIDMuOSAyMCA1IDIwSDE5QzIwLjEgMjAgMjEgMTkuMSAyMSAxOFY4QzIxIDcuNCAyMC42IDcgMjAgN1oiIGZpbGw9IiM0RjQ2RTUiLz4KPC9zdmc+Cg==",
};

// Универсальный компонент иконки
interface CustomIconProps {
  className?: string;
  onClick?: () => void;
  [key: string]: any;
}

// Замена Star
export const Star: React.FC<CustomIconProps> = ({ className = "w-4 h-4", ...props }) => {
  const [error, setError] = useState(false);
  
  if (error) {
    return <LucideStar className={className} {...props} />;
  }
  
  return (
    <img 
      src={ICON_URLS.star}
      alt="Star"
      className={className}
      onError={() => setError(true)}
      {...props}
    />
  );
};

// Замена Bitcoin  
export const Bitcoin: React.FC<CustomIconProps> = ({ className = "w-4 h-4", ...props }) => {
  const [error, setError] = useState(false);
  
  if (error) {
    return <LucideBitcoin className={className} {...props} />;
  }
  
  return (
    <img 
      src={ICON_URLS.bitcoin}
      alt="Bitcoin"
      className={className}
      onError={() => setError(true)}
      {...props}
    />
  );
};

// Замена Coins (для TON)
export const Coins: React.FC<CustomIconProps> = ({ className = "w-4 h-4", ...props }) => {
  const [error, setError] = useState(false);
  
  if (error) {
    return <LucideCoins className={className} {...props} />;
  }
  
  return (
    <img 
      src={ICON_URLS.ton}
      alt="TON"
      className={className}
      onError={() => setError(true)}
      {...props}
    />
  );
};

// Замена Shield
export const Shield: React.FC<CustomIconProps> = ({ className = "w-4 h-4", ...props }) => {
  const [error, setError] = useState(false);
  
  if (error) {
    return <LucideShield className={className} {...props} />;
  }
  
  return (
    <img 
      src={ICON_URLS.shield}
      alt="Shield"
      className={className}
      onError={() => setError(true)}
      {...props}
    />
  );
};

// Замена BarChart3
export const BarChart3: React.FC<CustomIconProps> = ({ className = "w-4 h-4", ...props }) => {
  const [error, setError] = useState(false);
  
  if (error) {
    return <LucideBarChart3 className={className} {...props} />;
  }
  
  return (
    <img 
      src={ICON_URLS.chart}
      alt="Chart"
      className={className}
      onError={() => setError(true)}
      {...props}
    />
  );
};

// Замена Share (для Telegram)
export const Share: React.FC<CustomIconProps> = ({ className = "w-4 h-4", ...props }) => {
  const [error, setError] = useState(false);
  
  if (error) {
    return <LucideShare className={className} {...props} />;
  }
  
  return (
    <img 
      src={ICON_URLS.telegram}
      alt="Telegram"
      className={className}
      onError={() => setError(true)}
      {...props}
    />
  );
};

// Экспортируем остальные иконки из lucide-react БЕЗ ИЗМЕНЕНИЙ
export { 
  ShoppingCart,
  Calculator,
  ExternalLink, // ← Эта иконка теперь должна работать
  CalendarDays,
  ThumbsUp,
  CheckCircle,
  Users,
  Copy,
  Tag,
  History,
  Moon,
  Sun,
  User,
  TrendingUp,
  ChevronRight,
  MoreHorizontal,
  DollarSign,
  Activity,
  ArrowLeft,
  Bell, 
  Palette,Receipt,
  ChevronDown, ChevronUp, Target, Gift

};

================================================================================
FILE: frontend\src\components\ui\dialog.tsx
================================================================================

"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}


================================================================================
FILE: frontend\src\components\ui\drawer.tsx
================================================================================

"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}


================================================================================
FILE: frontend\src\components\ui\dropdown-menu.tsx
================================================================================

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}


================================================================================
FILE: frontend\src\components\ui\form.tsx
================================================================================

"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}


================================================================================
FILE: frontend\src\components\ui\hover-card.tsx
================================================================================

"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }


================================================================================
FILE: frontend\src\components\ui\input-otp.tsx
================================================================================

import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }


================================================================================
FILE: frontend\src\components\ui\input.tsx
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }


================================================================================
FILE: frontend\src\components\ui\label.tsx
================================================================================

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }


================================================================================
FILE: frontend\src\components\ui\menubar.tsx
================================================================================

"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup {...props} />
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}


================================================================================
FILE: frontend\src\components\ui\navigation-menu.tsx
================================================================================

import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}


================================================================================
FILE: frontend\src\components\ui\pagination.tsx
================================================================================

import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}


================================================================================
FILE: frontend\src\components\ui\popover.tsx
================================================================================

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }


================================================================================
FILE: frontend\src\components\ui\progress.tsx
================================================================================

"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-gray-200 dark:bg-gray-700",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-gradient-to-r from-[#4E7FFF] to-purple-500 transition-all duration-500 ease-out"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

================================================================================
FILE: frontend\src\components\ui\radio-group.tsx
================================================================================

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }


================================================================================
FILE: frontend\src\components\ui\resizable.tsx
================================================================================

"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }


================================================================================
FILE: frontend\src\components\ui\scroll-area.tsx
================================================================================

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }


================================================================================
FILE: frontend\src\components\ui\select.tsx
================================================================================

"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}


================================================================================
FILE: frontend\src\components\ui\separator.tsx
================================================================================

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }


================================================================================
FILE: frontend\src\components\ui\sheet.tsx
================================================================================

"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}


================================================================================
FILE: frontend\src\components\ui\sidebar.tsx
================================================================================

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContextProps>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <SheetHeader className="sr-only">
              <SheetTitle>Sidebar</SheetTitle>
              <SheetDescription>Displays the mobile sidebar.</SheetDescription>
            </SheetHeader>
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex w-full flex-1 flex-col bg-background",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}


================================================================================
FILE: frontend\src\components\ui\skeleton.tsx
================================================================================

import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }


================================================================================
FILE: frontend\src\components\ui\slider.tsx
================================================================================

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }


================================================================================
FILE: frontend\src\components\ui\switch.tsx
================================================================================

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }


================================================================================
FILE: frontend\src\components\ui\table.tsx
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}


================================================================================
FILE: frontend\src\components\ui\tabs.tsx
================================================================================

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }


================================================================================
FILE: frontend\src\components\ui\textarea.tsx
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }


================================================================================
FILE: frontend\src\components\ui\toast.tsx
================================================================================

// В файле frontend/src/components/ui/toast.tsx
// Замените весь файл или найдите и замените эти части:

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-lg border p-6 pr-8 shadow-2xl backdrop-blur-md transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border-gray-200 dark:border-gray-700 bg-white/95 dark:bg-gray-900/95 text-gray-900 dark:text-gray-100 shadow-lg",
        destructive:
          "destructive group border-red-200 dark:border-red-800 bg-red-50/95 dark:bg-red-950/95 text-red-900 dark:text-red-100",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-gray-600 dark:text-gray-400 opacity-70 transition-opacity hover:text-gray-900 dark:hover:text-gray-100 hover:opacity-100 focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold text-gray-900 dark:text-gray-100", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm text-gray-700 dark:text-gray-300", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose, 
  ToastAction,
} 

================================================================================
FILE: frontend\src\components\ui\toaster.tsx
================================================================================

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}


================================================================================
FILE: frontend\src\components\ui\toggle-group.tsx
================================================================================

"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }


================================================================================
FILE: frontend\src\components\ui\toggle.tsx
================================================================================

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }


================================================================================
FILE: frontend\src\components\ui\tooltip.tsx
================================================================================

"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }


================================================================================
FILE: frontend\src\hooks\use-mobile.tsx
================================================================================

import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}


================================================================================
FILE: frontend\src\hooks\use-preload-avatar.ts
================================================================================

// frontend/src/hooks/use-preload-avatar.ts
import { useState, useEffect } from 'react';
import type { SnakeCaseUser } from "../../shared/schema";

interface AvatarData {
  photo_url: string;
  first_name: string;
}

interface UsePreloadAvatarResult {
  avatar: AvatarData | null;
  isLoading: boolean;
  error: string | null;
}

// Кеш для хранения фото в памяти во время сессии
const avatarCache = new Map<string, AvatarData>();

export function usePreloadAvatar(user?: SnakeCaseUser | null): UsePreloadAvatarResult {
  const [avatar, setAvatar] = useState<AvatarData | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!user?.username?.trim()) {
      setAvatar(null);
      setIsLoading(false);
      return;
    }

    const username = user.username.trim();
    
    // Проверяем кеш
    if (avatarCache.has(username)) {
      setAvatar(avatarCache.get(username)!);
      setIsLoading(false);
      return;
    }

    // Загружаем фото
    const fetchAvatar = async () => {
      setIsLoading(true);
      setError(null);
      
      try {
        const response = await fetch(`/api/getPhoto?username=${username}`);
        const data = await response.json();
        
        if (data.success) {
          // Сохраняем в кеш
          avatarCache.set(username, data);
          setAvatar(data);
        } else {
          setError(data.error || 'Failed to load avatar');
          setAvatar(null);
        }
      } catch (e) {
        setError('Network error');
        setAvatar(null);
      } finally {
        setIsLoading(false);
      }
    };

    fetchAvatar();
  }, [user?.username]);

  return { avatar, isLoading, error };
}

================================================================================
FILE: frontend\src\hooks\use-telegram.ts
================================================================================

import { useState, useEffect } from 'react';
import { telegramWebApp, type TelegramUser } from '@/lib/telegram';

export function useTelegram() {
  const [user, setUser] = useState<TelegramUser | null>(null);
  const [isAvailable, setIsAvailable] = useState(false);
  const [colorScheme, setColorScheme] = useState<'light' | 'dark'>('dark');

  useEffect(() => {
    const available = telegramWebApp.isAvailable();
    setIsAvailable(available);

    if (available) {
      setUser(telegramWebApp.getUser());
      setColorScheme(telegramWebApp.getColorScheme());
    }
  }, []);

  const showAlert = (message: string) => {
    telegramWebApp.showAlert(message);
  };

  const showConfirm = (message: string, callback: (confirmed: boolean) => void) => {
    telegramWebApp.showConfirm(message, callback);
  };

  const hapticFeedback = (type?: 'light' | 'medium' | 'heavy' | 'success' | 'error' | 'warning') => {
    telegramWebApp.hapticFeedback(type);
  };

  const close = () => {
    telegramWebApp.close();
  };

  const shareApp = (message: string = 'Попробуй этот крутой обменник Stars и TON!') => {
    telegramWebApp.switchInlineQuery(message, ['users']);
  };

  return {
    user,
    isAvailable,
    colorScheme,
    showAlert,
    showConfirm,
    hapticFeedback,
    close,
    shareApp,
  };
}


================================================================================
FILE: frontend\src\hooks\use-theme.ts
================================================================================

import { useState, useEffect } from 'react';
import { useTelegram } from './use-telegram';

export function useTheme() {
  const { colorScheme } = useTelegram();
  const [theme, setTheme] = useState<'light' | 'dark'>('dark');

  useEffect(() => {
    // Initialize theme based on Telegram's color scheme or localStorage
    const savedTheme = localStorage.getItem('theme') as 'light' | 'dark' | null;
    const initialTheme = savedTheme || colorScheme || 'dark';
    setTheme(initialTheme);
    updateDocumentTheme(initialTheme);
  }, [colorScheme]);

  const updateDocumentTheme = (newTheme: 'light' | 'dark') => {
    const root = document.documentElement;
    
    if (newTheme === 'dark') {
      root.classList.add('dark');
    } else {
      root.classList.remove('dark');
    }
  };

  const toggleTheme = () => {
    const newTheme = theme === 'light' ? 'dark' : 'light';
    setTheme(newTheme);
    localStorage.setItem('theme', newTheme);
    updateDocumentTheme(newTheme);
  };

  return {
    theme,
    toggleTheme,
    isDark: theme === 'dark',
  };
}


================================================================================
FILE: frontend\src\hooks\use-toast.ts
================================================================================

import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }


================================================================================
FILE: frontend\src\hooks\use-user-avatar.ts
================================================================================

import { useState, useEffect } from 'react';

export function useUserAvatar(username?: string | null) {
  const [avatar, setAvatar] = useState<{photo_url: string, first_name: string} | null>(null);

  useEffect(() => {
    if (!username?.trim()) return;

    const fetchAvatar = async () => {
      try {
        const response = await fetch(`/api/getPhoto?username=${username.trim()}`);
        const data = await response.json();
        if (data.success) setAvatar(data);
      } catch (e) {}
    };

    fetchAvatar();
  }, [username]);

  return avatar;
}

================================================================================
FILE: frontend\src\lib\queryClient.ts
================================================================================

import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response> {
  const headers: Record<string, string> = {};
  
  // Получаем initData из Telegram Web App
  const initData = (window as any).Telegram?.WebApp?.initData;
  if (initData) {
    headers['x-telegram-init-data'] = initData;
  }
  
  if (data) {
    headers['Content-Type'] = 'application/json';
  }
  
  const res = await fetch(url, {
    method,
    headers,
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
  });

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    const headers: Record<string, string> = {};
    
    // Получаем initData из Telegram Web App
    const initData = (window as any).Telegram?.WebApp?.initData;
    if (initData) {
      headers['x-telegram-init-data'] = initData;
    }
    
    const res = await fetch(queryKey.join("/") as string, {
      headers,
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: 0,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});


================================================================================
FILE: frontend\src\lib\telegram.ts
================================================================================

declare global {
  interface Window {
    Telegram?: {
      WebApp: {
        ready(): void;
        expand(): void;
        close(): void;
        initData: string;
        initDataUnsafe: {
          user?: {
            id: number;
            first_name: string;
            last_name?: string;
            username?: string;
            language_code?: string;
          };
          chat_instance?: string;
          chat_type?: string;
          start_param?: string;
        };
        colorScheme: 'light' | 'dark';
        themeParams: {
          bg_color: string;
          text_color: string;
          hint_color: string;
          link_color: string;
          button_color: string;
          button_text_color: string;
        };
        isExpanded: boolean;
        viewportHeight: number;
        viewportStableHeight: number;
        headerColor: string;
        backgroundColor: string;
        onEvent(eventType: string, eventHandler: () => void): void;
        offEvent(eventType: string, eventHandler: () => void): void;
        showAlert(message: string): void;
        showConfirm(message: string, callback: (confirmed: boolean) => void): void;
        showPopup(params: {
          title?: string;
          message: string;
          buttons?: Array<{
            id?: string;
            type?: 'default' | 'ok' | 'close' | 'cancel' | 'destructive';
            text: string;
          }>;
        }, callback?: (buttonId: string) => void): void;
        switchInlineQuery(query: string, chatTypes?: string[]): void;
        MainButton: {
          text: string;
          color: string;
          textColor: string;
          isVisible: boolean;
          isActive: boolean;
          readonly isProgressVisible: boolean;
          show(): void;
          hide(): void;
          enable(): void;
          disable(): void;
          showProgress(leaveActive?: boolean): void;
          hideProgress(): void;
          setText(text: string): void;
          onClick(callback: () => void): void;
          offClick(callback: () => void): void;
        };
        BackButton: {
          isVisible: boolean;
          show(): void;
          hide(): void;
          onClick(callback: () => void): void;
          offClick(callback: () => void): void;
        };
        HapticFeedback: {
          impactOccurred(style: 'light' | 'medium' | 'heavy' | 'rigid' | 'soft'): void;
          notificationOccurred(type: 'error' | 'success' | 'warning'): void;
          selectionChanged(): void;
        };
      };
    };
  }
}

export interface TelegramUser {
  id: number;
  first_name: string;
  last_name?: string;
  username?: string;
  language_code?: string;
}

export class TelegramWebApp {
  private static instance: TelegramWebApp;
  public webApp: any = null;

  private constructor() {
    if (typeof window !== 'undefined' && window.Telegram?.WebApp) {
      this.webApp = window.Telegram.WebApp;
      this.init();
    }
  }

  static getInstance(): TelegramWebApp {
    if (!TelegramWebApp.instance) {
      TelegramWebApp.instance = new TelegramWebApp();
    }
    return TelegramWebApp.instance;
  }

  private init() {
    if (this.webApp) {
      this.webApp.ready();
      this.webApp.expand();
    }
  }

  isAvailable(): boolean {
    return this.webApp !== null;
  }

  getUser(): TelegramUser | null {
    return this.webApp?.initDataUnsafe?.user || null;
  }

  getStartParam(): string | null {
    return this.webApp?.initDataUnsafe?.start_param || null;
  }

  getColorScheme(): 'light' | 'dark' {
    return this.webApp?.colorScheme || 'dark';
  }

  showAlert(message: string) {
    if (this.webApp) {
      this.webApp.showAlert(message);
    } else {
      alert(message);
    }
  }

  showConfirm(message: string, callback: (confirmed: boolean) => void) {
    if (this.webApp) {
      this.webApp.showConfirm(message, callback);
    } else {
      const confirmed = confirm(message);
      callback(confirmed);
    }
  }

  hapticFeedback(type: 'light' | 'medium' | 'heavy' | 'success' | 'error' | 'warning' = 'light') {
    if (this.webApp?.HapticFeedback) {
      if (type === 'success' || type === 'error' || type === 'warning') {
        this.webApp.HapticFeedback.notificationOccurred(type);
      } else {
        this.webApp.HapticFeedback.impactOccurred(type);
      }
    }
  }

  close() {
    if (this.webApp) {
      this.webApp.close();
    } else {
      window.close();
    }
  }

  switchInlineQuery(query: string, chatTypes?: string[]) {
    if (this.webApp) {
      this.webApp.switchInlineQuery(query, chatTypes);
    }
  }
  getInitData(): string | null {
    return this.webApp?.initData || null;
  }
}

export const telegramWebApp = TelegramWebApp.getInstance();

================================================================================
FILE: frontend\src\lib\utils.ts
================================================================================

import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


================================================================================
FILE: frontend\src\pages\admin.tsx
================================================================================

import React, { useEffect, useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useToast } from "@/hooks/use-toast";
import { useTelegram } from "@/hooks/use-telegram";
import {
  Shield,
  BarChart3,
  Tag,
  History,
  Users,
  DollarSign,
  Activity,
  ArrowLeft,
  TrendingUp,
  ChevronDown,
  ChevronUp,
} from "@/components/ui/custom-icons";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Link } from "wouter";

type AdminStats = {
  totalUsers?: number;
  todaySales?: string;
  activeReferrals?: number;
  recentTransactions?: Array<{
    id: string | number;
    username: string;
    description?: string;
    status?: "completed" | "failed" | "pending" | string;
    createdAt?: string;
  }>;
};

type CurrentSettings = {
  stars_price?: string | number;
  ton_markup_percentage?: string | number;
  ton_price_cache_minutes?: string | number;
  ton_fallback_price?: string | number;
  bot_base_url?: string;
  referral_prefix?: string;
  referral_bonus_percentage?: string | number;
  referral_registration_bonus?: string | number;
};

type TONPriceData = {
  price: string;
};

export default function AdminPage(): JSX.Element {
  const [starsPrice, setStarsPrice] = useState<string>("");
  const [tonMarkupPercentage, setTonMarkupPercentage] = useState<string>("");
  const [tonCacheMinutes, setTonCacheMinutes] = useState<string>("");
  const [tonFallbackPrice, setTonFallbackPrice] = useState<string>("");
  const [botBaseUrl, setBotBaseUrl] = useState<string>("");
  const [referralPrefix, setReferralPrefix] = useState<string>("");
  const [referralBonusPercentage, setReferralBonusPercentage] = useState<string>("");
  const [referralRegistrationBonus, setReferralRegistrationBonus] = useState<string>("");
  const [showTransactions, setShowTransactions] = useState<boolean>(false);
  
  const { toast } = useToast();
  const { hapticFeedback } = useTelegram();
  const queryClient = useQueryClient();

  const normalizeToStringNumber = (value: any, fallback: string = ""): string => {
    if (value === null || value === undefined || value === "") {
      return fallback;
    }
    if (typeof value === "string") {
      const trimmed = value.trim();
      if (trimmed === "") return fallback;
      const num = parseFloat(trimmed.replace(",", "."));
      return Number.isFinite(num) ? trimmed : fallback;
    }
    if (typeof value === "number" && Number.isFinite(value)) {
      return String(value);
    }
    return fallback;
  };

  const parseNumberOrNaN = (s: string) => {
    if (typeof s !== "string") return NaN;
    const cleaned = s.trim().replace(",", ".");
    const n = parseFloat(cleaned);
    return Number.isFinite(n) ? n : NaN;
  };

  // Запрос текущих настроек
  const { data: currentSettings } = useQuery<CurrentSettings, Error>({
    queryKey: ["/api/admin/settings/current"],
    queryFn: async () => {
      const res = await fetch("/api/admin/settings/current", {
        method: "GET",
        headers: { "Content-Type": "application/json" },
      });
      if (!res.ok) throw new Error(`Failed to fetch current settings: ${res.status}`);
      return res.json();
    },
    staleTime: 1000 * 60 * 5,
  });

  // 🚀 Запрос цены TON
  const { data: tonPriceData, isLoading: isTonPriceLoading } = useQuery<TONPriceData, Error>({
    queryKey: ["/api/ton-price"],
    queryFn: async () => {
      const res = await fetch("/api/ton-price", {
        method: "GET",
        headers: { "Content-Type": "application/json" },
      });
      if (!res.ok) throw new Error(`Failed to fetch TON price: ${res.status}`);
      return res.json();
    },
    refetchInterval: 60000,
    staleTime: 30000,
    refetchOnWindowFocus: true,
  });

  // 🚀 Запрос реальной статистики
  const { data: adminStats, isLoading: isStatsLoading } = useQuery<AdminStats, Error>({
    queryKey: ["/api/admin/stats"],
    queryFn: async () => {
      const res = await fetch("/api/admin/stats", {
        method: "GET",
        headers: { "Content-Type": "application/json" },
      });
      if (!res.ok) throw new Error(`Failed to fetch admin stats: ${res.status}`);
      return res.json() as Promise<AdminStats>;
    },
    staleTime: 1000 * 30,
    refetchInterval: 60000, // Обновляем каждую минуту
  });

  useEffect(() => {
    if (!currentSettings) return;
    
    setStarsPrice(normalizeToStringNumber(currentSettings.stars_price, "1.50"));
    setTonMarkupPercentage(normalizeToStringNumber(currentSettings.ton_markup_percentage, "5.0"));
    setTonCacheMinutes(normalizeToStringNumber(currentSettings.ton_price_cache_minutes, "15"));
    setTonFallbackPrice(normalizeToStringNumber(currentSettings.ton_fallback_price, "420.0"));
    setReferralRegistrationBonus(normalizeToStringNumber(currentSettings.referral_registration_bonus, "25.0"));
    
    setBotBaseUrl(currentSettings.bot_base_url || "https://t.me/starsguru_official_bot");
    setReferralPrefix(currentSettings.referral_prefix || "ref");
    setReferralBonusPercentage(normalizeToStringNumber(currentSettings.referral_bonus_percentage, "5.0"));
  }, [currentSettings]);

  const updateSettingsMutation = useMutation({
    mutationFn: async (payload: Record<string, any>) => {
      const res = await fetch("/api/admin/settings", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      
      const text = await res.text().catch(() => "");
      let json;
      try {
        json = text ? JSON.parse(text) : null;
      } catch {
        json = text;
      }
      
      if (!res.ok) {
        throw new Error(`Ошибка обновления: ${res.status} ${JSON.stringify(json)}`);
      }
      
      return json;
    },
    onSuccess: (data) => {
      hapticFeedback("success");
      
      let description = "Настройки успешно обновлены";
      if (data?.ton_price_updated && data?.new_ton_price) {
        description = `Настройки обновлены. Новая цена TON: ₽${data.new_ton_price}`;
      }
      
      toast({ 
        title: "Настройки обновлены", 
        description: description
      });
      
      queryClient.invalidateQueries({ queryKey: ["/api/admin/settings/current"] });
      queryClient.invalidateQueries({ queryKey: ["/api/admin/stats"] });
      
      if (data?.ton_price_updated) {
        queryClient.invalidateQueries({ queryKey: ["/api/ton-price"] });
      }
    },
    onError: (err: any) => {
      hapticFeedback("error");
      toast({ 
        title: "Ошибка", 
        description: `Не удалось обновить настройки: ${err.message}`, 
        variant: "destructive" 
      });
    },
  });

  const handleUpdatePrices = () => {
    if (!starsPrice || !botBaseUrl || !referralPrefix || !referralBonusPercentage || 
        !tonMarkupPercentage || !referralRegistrationBonus || 
        !tonCacheMinutes || !tonFallbackPrice) {
      toast({ 
        title: "Ошибка валидации", 
        description: "Все поля должны быть заполнены", 
        variant: "destructive" 
      });
      return;
    }

    const s = parseNumberOrNaN(starsPrice);
    const rbp = parseNumberOrNaN(referralBonusPercentage);
    const tmp = parseNumberOrNaN(tonMarkupPercentage);
    const tcm = parseNumberOrNaN(tonCacheMinutes);
    const tfp = parseNumberOrNaN(tonFallbackPrice);
    const rrb = parseNumberOrNaN(referralRegistrationBonus);

    if (Number.isNaN(s) || Number.isNaN(rbp) || Number.isNaN(tmp) || 
        Number.isNaN(tcm) || Number.isNaN(tfp) || Number.isNaN(rrb)) {
      toast({ 
        title: "Ошибка валидации", 
        description: "Пожалуйста, введите корректные числовые значения.", 
        variant: "destructive" 
      });
      return;
    }
    
    if (s <= 0 || rbp < 0 || tmp < 0 || tcm <= 0 || tfp <= 0 || rrb < 0) {
      toast({ 
        title: "Ошибка валидации", 
        description: "Все значения должны быть положительными.", 
        variant: "destructive" 
      });
      return;
    }

    updateSettingsMutation.mutate({
      stars_price: starsPrice,
      ton_markup_percentage: tonMarkupPercentage,
      ton_price_cache_minutes: tonCacheMinutes,
      ton_fallback_price: tonFallbackPrice,
      referral_registration_bonus: referralRegistrationBonus,
      bot_base_url: botBaseUrl,
      referral_prefix: referralPrefix,
      referral_bonus_percentage: referralBonusPercentage,
    });
  };

  return (
    <div className="min-h-screen bg-white dark:bg-[#0E0E10] text-gray-900 dark:text-white">
      <header className="sticky top-0 z-50 bg-white/80 dark:bg-[#0E0E10]/80 backdrop-blur-lg border-b border-gray-200 dark:border-white/10">
        <div className="flex items-center justify-between p-4">
          <Link href="/">
            <Button variant="ghost" size="icon" aria-label="Back">
              <ArrowLeft className="w-4 h-4" />
            </Button>
          </Link>
          <h1 className="text-lg font-bold flex items-center">
            <Shield className="w-5 h-5 text-[#4E7FFF] mr-2" /> Админ панель
          </h1>
          <div style={{ width: 36 }} />
        </div>
      </header>

      <main className="p-4 space-y-6">
        {/* 🚀 УЛУЧШЕННАЯ СТАТИСТИКА */}
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <motion.div 
            className="bg-gradient-to-br from-blue-50 to-blue-100 dark:from-blue-900/20 dark:to-blue-800/20 rounded-xl p-4 border border-blue-200 dark:border-blue-700"
            initial={{ opacity: 0, y: 20 }} 
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0 }}
          >
            <div className="flex items-center justify-between mb-2">
              <Users className="w-8 h-8 text-blue-500" />
              {isStatsLoading && <div className="w-4 h-4 animate-spin border-2 border-blue-500 border-t-transparent rounded-full" />}
            </div>
            <h3 className="text-2xl font-bold text-blue-600 dark:text-blue-400">
              {adminStats?.totalUsers?.toLocaleString() || 0}
            </h3>
            <p className="text-sm text-gray-600 dark:text-gray-400">Всего пользователей</p>
          </motion.div>

          <motion.div 
            className="bg-gradient-to-br from-green-50 to-green-100 dark:from-green-900/20 dark:to-green-800/20 rounded-xl p-4 border border-green-200 dark:border-green-700"
            initial={{ opacity: 0, y: 20 }} 
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.1 }}
          >
            <div className="flex items-center justify-between mb-2">
              <DollarSign className="w-8 h-8 text-green-500" />
              <TrendingUp className="w-5 h-5 text-green-400" />
            </div>
            <h3 className="text-2xl font-bold text-green-600 dark:text-green-400">
              ₽{adminStats?.todaySales ? parseFloat(adminStats.todaySales).toLocaleString() : '0'}
            </h3>
            <p className="text-sm text-gray-600 dark:text-gray-400">Продаж сегодня</p>
          </motion.div>

          <motion.div 
            className="bg-gradient-to-br from-purple-50 to-purple-100 dark:from-purple-900/20 dark:to-purple-800/20 rounded-xl p-4 border border-purple-200 dark:border-purple-700"
            initial={{ opacity: 0, y: 20 }} 
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.2 }}
          >
            <div className="flex items-center justify-between mb-2">
              <Activity className="w-8 h-8 text-purple-500" />
            </div>
            <h3 className="text-2xl font-bold text-purple-600 dark:text-purple-400">
              {adminStats?.activeReferrals || 0}
            </h3>
            <p className="text-sm text-gray-600 dark:text-gray-400">Активных рефералов</p>
          </motion.div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* Price Settings */}
          <motion.div
            className="bg-gray-50 dark:bg-[#0E0E10] rounded-xl p-4"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.3 }}
          >
            <h3 className="font-semibold mb-3 flex items-center">
              <Tag className="w-4 h-4 text-green-500 mr-2" />
              Цены
            </h3>
            <div className="space-y-4">
              <div>
                <Label>Цена Stars (₽)</Label>
                <Input
                  type="number"
                  step="0.01"
                  value={starsPrice}
                  onChange={(e) => setStarsPrice(e.target.value)}
                  placeholder="1.50"
                />
              </div>
              <Button
                onClick={handleUpdatePrices}
                disabled={updateSettingsMutation.isPending}
                className="w-full"
              >
                {updateSettingsMutation.isPending
                  ? "Обновляется..."
                  : "Обновить настройки"}
              </Button>
            </div>
          </motion.div>

          {/* TON Dynamic Pricing */}
          <motion.div
            className="bg-gray-50 dark:bg-[#0E0E10] rounded-xl p-4"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.4 }}
          >
            <h3 className="font-semibold mb-3 flex items-center">
              🚀 TON ценообразование
              {updateSettingsMutation.isPending && (
                <div className="ml-2 animate-spin w-4 h-4 border-2 border-blue-500 border-t-transparent rounded-full" />
              )}
            </h3>
            
            {/* Текущая цена TON */}
            {tonPriceData?.price && (
              <div className="mb-4 p-3 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                <div className="flex justify-between items-center">
                  <span className="text-sm font-medium">Текущая цена:</span>
                  <span className="font-bold text-lg text-blue-600">
                    {isTonPriceLoading ? (
                      <span className="animate-pulse">Обновляется...</span>
                    ) : (
                      `₽${parseFloat(tonPriceData.price).toFixed(2)}`
                    )}
                  </span>
                </div>
              </div>
            )}
            
            <div className="grid grid-cols-2 gap-4">
              <div>
                <Label>Наценка (%)</Label>
                <Input
                  type="number"
                  step="0.1"
                  value={tonMarkupPercentage}
                  onChange={(e) => setTonMarkupPercentage(e.target.value)}
                  placeholder="5"
                />
              </div>
              <div>
                <Label>Резервная цена (₽)</Label>
                <Input
                  type="number"
                  step="0.01"
                  value={tonFallbackPrice}
                  onChange={(e) => setTonFallbackPrice(e.target.value)}
                  placeholder="420"
                />
              </div>
            </div>
          </motion.div>
        </div>

        {/* Referral Settings */}
        <motion.div
          className="bg-gray-50 dark:bg-[#0E0E10] rounded-xl p-4"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.5 }}
        >
          <h3 className="font-semibold mb-3 flex items-center">
            <Shield className="w-4 h-4 text-blue-500 mr-2" />
            Реферальные настройки
          </h3>
          <div className="grid grid-cols-2 gap-4">
            <div>
              <Label>URL бота</Label>
              <Input
                value={botBaseUrl}
                onChange={(e) => setBotBaseUrl(e.target.value)}
                placeholder="https://t.me/bot_name"
              />
            </div>
            <div>
              <Label>Префикс реферальных ссылок</Label>
              <Input
                value={referralPrefix}
                onChange={(e) => setReferralPrefix(e.target.value)}
                placeholder="ref"
              />
            </div>
            <div>
              <Label>Процент с покупок (%)</Label>
              <Input
                type="number"
                step="0.1"
                value={referralBonusPercentage}
                onChange={(e) => setReferralBonusPercentage(e.target.value)}
                placeholder="5"
              />
            </div>
            <div>
              <Label>Награда за приглашение 🎁</Label>
              <Input
                type="number"
                value={referralRegistrationBonus}
                onChange={(e) => setReferralRegistrationBonus(e.target.value)}
                placeholder="25"
              />
            </div>
          </div>
        </motion.div>

        {/* 🚀 УЛУЧШЕННЫЕ ТРАНЗАКЦИИ */}
        <motion.div
          className="bg-gray-50 dark:bg-[#0E0E10] rounded-xl p-4"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.6 }}
        >
          <div className="flex items-center justify-between mb-3">
            <h3 className="font-semibold flex items-center">
              <History className="w-4 h-4 text-[#4E7FFF] mr-2" />
              Последние транзакции
            </h3>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => setShowTransactions(!showTransactions)}
              className="flex items-center gap-1"
            >
              {showTransactions ? <ChevronUp className="w-4 h-4" /> : <ChevronDown className="w-4 h-4" />}
              {showTransactions ? 'Свернуть' : 'Развернуть'}
            </Button>
          </div>
          
          <AnimatePresence>
            <motion.div 
              className="space-y-2 max-h-80 overflow-y-auto"
              initial={false}
              animate={{ height: showTransactions ? 'auto' : '200px' }}
              transition={{ duration: 0.3 }}
            >
              {adminStats?.recentTransactions?.length ? (
                adminStats.recentTransactions
                  .slice(0, showTransactions ? adminStats.recentTransactions.length : 3)
                  .map((transaction, index) => (
                    <motion.div
                      key={`${transaction.id}-${index}`}
                      className="flex justify-between items-center p-3 bg-white dark:bg-[#1A1A1C] rounded-lg border border-gray-200 dark:border-white/10"
                      initial={{ opacity: 0, x: -20 }}
                      animate={{ opacity: 1, x: 0 }}
                      transition={{ delay: index * 0.1 }}
                    >
                      <div className="flex-1">
                        <p className="font-medium text-sm">{transaction.username}</p>
                        <p className="text-xs text-gray-600 dark:text-gray-400">
                          {transaction.description}
                        </p>
                      </div>
                      <div className="text-right">
                        <span className={`text-xs font-semibold px-2 py-1 rounded-full ${
                          transaction.status === 'completed' ? 'bg-green-100 text-green-700 dark:bg-green-900/20 dark:text-green-400' : 
                          transaction.status === 'failed' ? 'bg-red-100 text-red-700 dark:bg-red-900/20 dark:text-red-400' : 
                          'bg-yellow-100 text-yellow-700 dark:bg-yellow-900/20 dark:text-yellow-400'
                        }`}>
                          {transaction.status === 'completed' ? '✓' : 
                          transaction.status === 'failed' ? '✗' : '⏳'}
                        </span>
                        <p className="text-xs text-gray-500 mt-1">
                          {transaction.createdAt ? new Date(transaction.createdAt).toLocaleDateString('ru') : ''}
                        </p>
                      </div>
                    </motion.div>
                  ))
              ) : (
                <p className="text-gray-500 text-center py-8">Нет транзакций</p>
              )}
            </motion.div>
          </AnimatePresence>
        </motion.div>
      </main>
    </div>
  );
}

================================================================================
FILE: frontend\src\pages\home.tsx
================================================================================

import TelegramApp from "@/components/telegram-app";
import TelegramGuard from "@/components/telegram-guard";

export default function Home() {
  return (
    <TelegramGuard>
      <TelegramApp />
    </TelegramGuard>
  );
}

================================================================================
FILE: frontend\src\pages\not-found.tsx
================================================================================

import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";

export default function NotFound() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md mx-4">
        <CardContent className="pt-6">
          <div className="flex mb-4 gap-2">
            <AlertCircle className="h-8 w-8 text-red-500" />
            <h1 className="text-2xl font-bold text-gray-900">404 Page Not Found</h1>
          </div>

          <p className="mt-4 text-sm text-gray-600">
            Did you forget to add the page to the router?
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
